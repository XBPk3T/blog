<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-2024/geektime202410" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">速读几本极客时间课程 | Lucas Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://xbpk3t.github.io/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://xbpk3t.github.io/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://xbpk3t.github.io/zh-Hans/2024/golang-project-dev-practice"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="速读几本极客时间课程 | Lucas Blog"><meta data-rh="true" name="description" content="《Go 语言项目开发实战》读书笔记"><meta data-rh="true" property="og:description" content="《Go 语言项目开发实战》读书笔记"><link data-rh="true" rel="icon" href="/zh-Hans/img/favicon.svg"><link data-rh="true" rel="canonical" href="https://xbpk3t.github.io/zh-Hans/2024/golang-project-dev-practice"><link data-rh="true" rel="alternate" href="https://xbpk3t.github.io/zh-Hans/2024/golang-project-dev-practice" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://xbpk3t.github.io/2024/golang-project-dev-practice" hreflang="en"><link data-rh="true" rel="alternate" href="https://xbpk3t.github.io/2024/golang-project-dev-practice" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://RV6E9N0CVW-dsn.algolia.net" crossorigin="anonymous"><link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G0687BFERF"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-G0687BFERF",{anonymize_ip:!0})</script>


<link rel="search" type="application/opensearchdescription+xml" title="Lucas Blog" href="/zh-Hans/opensearch.xml"><link rel="stylesheet" href="/zh-Hans/assets/css/styles.125f8fbe.css">
<script src="/zh-Hans/assets/js/runtime~main.73fe2c4a.js" defer="defer"></script>
<script src="/zh-Hans/assets/js/main.570fd71d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/zh-Hans/"><div class="navbar__logo"><img src="/zh-Hans/img/logo.svg" alt="Hacking" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/zh-Hans/img/logo.svg" alt="Hacking" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Hacking</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/zh-Hans/">Archive</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active">2024</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/zh-Hans/2024/golang-project-dev-practice">速读几本极客时间课程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/reading-methods">《聪明的阅读者》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/monthly9">Monthly#9</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/mysql-45-lessons">《MySQL 45讲》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/how-mysql-works">《MySQL是怎么运行的》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/goreleaser">用 goreleaser 代替 changelogithub</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/tech-team-managing">《技术管理实战 36 讲》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/flomo-bulk-delete">flomo批量删除脚本</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/deprecated-commands">备份gh.yml中废弃的repo命令</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/alfred-vs">alfred-vs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024">s</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/running">running</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/Design-Pattern">设计模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/code-spec">代码规范</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/php">php.yml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/regex">regex</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/ssh-protocol">ssh协议</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/tcpdump">tcpdump</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/xq">相亲</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/zhihu">知乎文章摘录</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/buy-byd-seal-06gt">【海豹06GT】购车记录</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/feed-manage-2">信息源管理2</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/sun-zi">《孙子兵法》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/system-design-interview">《搞定系统设计：面试敲开大厂的门》</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/how-to-write-commentary">《时评写作十讲》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/how-to-write-book-review">怎么写书评？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/zai-zhi-tian-xia">《宰执天下》书评</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/weekly34">Weekly#34</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/wechat-read-app">微信读书APP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/weekly33">Weekly#33</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/golang-error">golang错误处理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/record-for-paris-olympics">巴黎奥运会纪录</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/sql">常用mysql sql整理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/pre-commit">为什么在CI中应该用pre-commit代替linters?</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/argumentative-writing">议论文</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/feed-manage-1">信息源管理1（rss）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/shell-syntax">shell脚本常用语法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/weekly13">Weekly#13</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/politics-of-legitimacy">《合法性的政治》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2024/leng-jing">【Hac棱镜】文章合集</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">2023</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/weekly52">Weekly#52</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/weekly40">Weekly#40</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/kernel">《趣谈 Linux 操作系统》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/network-protocol">network-protocol</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/secretary-work-handbook">《秘书工作手记》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/capital-in-the-twenty-first-century">《21世纪资本论》读书笔记</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/ru-zi-di">《孺子帝》读后感</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/renamer-tool">文件批量重命名工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/2023/feng-hua-marathon">复盘奉化马拉松</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link">2000</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/minimalist">极简生活</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/books">books.yml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs">docs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/movies">movies.yml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/music">music常识</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/tv">tv.yml</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/x">x</a></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/zh-Hans/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">2024</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">速读几本极客时间课程</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>速读几本极客时间课程</h1><div class="container_mg8B margin-vert--md"><time datetime="2024-10-7">2024年10月7日</time></div></header><div class="toolbar_VBrL"></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="go-语言项目开发实战读书笔记">《Go 语言项目开发实战》读书笔记<a href="#go-语言项目开发实战读书笔记" class="hash-link" aria-label="《Go 语言项目开发实战》读书笔记的直接链接" title="《Go 语言项目开发实战》读书笔记的直接链接">​</a></h2>
<p><a href="https://github.com/marmotedu/geekbang-go" target="_blank" rel="noopener noreferrer">marmotedu/geekbang-go: 极客时间 《Go 语言项目开发实战》课程补充教程。</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="git-commit">git commit<a href="#git-commit" class="hash-link" aria-label="git commit的直接链接" title="git commit的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/05%20%E8%A7%84%E8%8C%83%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9Acommit%20%E4%BF%A1%E6%81%AF%E9%A3%8E%E6%A0%BC%E8%BF%A5%E5%BC%82%E3%80%81%E9%9A%BE%E4%BB%A5%E9%98%85%E8%AF%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">05 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？</a></p>
<hr>
<p><img decoding="async" loading="lazy" alt="git-types-belongs.jpg" src="/zh-Hans/assets/images/git-types-belongs-29984be61385590e132e418e1f6ace07.jpg" width="726" height="511" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="git-commit-types.jpg" src="/zh-Hans/assets/images/git-commit-types-ad9d6c1019447f7b3dceb4ceb23e1ff6.jpg" width="2513" height="1078" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">如果我们变更了应用代码，比如某个 Go 函数代码，那这次修改属于代码类。在代码类中，有 4 种具有明确变更意图的类型：feat、fix、perf 和 style；如果我们的代码变更不属于这 4 类，那就全都归为 refactor 类，也就是优化代码。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果我们变更了非应用代码，例如更改了文档，那它属于非代码类。在非代码类中，有 3 种具有明确变更意图的类型：test、ci、docs；如果我们的非代码变更不属于这 3 类，那就全部归入到 chore 类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Angular 的 Commit Message 规范提供了大部分的 type，在实际开发中，我们可以使用部分 type，或者扩展添加我们自己的 type。但无论选择哪种方式，我们一定要保证一个项目中的 type 类型一致。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">提交频率</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在实际项目开发中，如果是个人项目，随意 commit 可能影响不大，但如果是多人开发的项目，随意 commit 不仅会让 Commit Message 变得难以理解，还会让其他研发同事觉得你不专业。因此，我们要规定 commit 的提交频率。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那到底什么时候进行 commit 最好呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我认为主要可以分成两种情况。一种情况是，只要我对项目进行了修改，一通过测试就立即 commit。比如修复完一个 bug、开发完一个小功能，或者开发完一个完整的功能，测试通过后就提交。另一种情况是，我们规定一个时间，定期提交。这里我  建议代码下班前固定提交一次，并且要确保本地未提交的代码，延期不超过 1 天。这样，如果本地代码丢失，可以尽可能减少丢失的代码量。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">按照上面 2 种方式提交代码，你可能会觉得代码 commit 比较多，看起来比较随意。或者说，我们想等开发完一个完整的功能之后，放在一个 commit 中一起提交。这时候，我们可以在最后合并代码或者提交 Pull Request 前，执行 git rebase -i 合并之前的所有 commit。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那么如何合并 commit 呢？接下来，我来详细说说。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">修改 Commit Message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="theme-admonition theme-admonition-danger admonition_xJq3 alert alert--danger"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>危险</div><div class="admonitionContent_BuS1"><ul>
<li>提交频率</li>
<li>合并提交</li>
<li>修改 commit message</li>
</ul></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="makefile">Makefile<a href="#makefile" class="hash-link" aria-label="Makefile的直接链接" title="Makefile的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/14%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84Makefile%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">14 项目管 理：如何编写高质量的Makefile？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">首先，你需要熟练掌握Makefile的语法。我建议你重点掌握以下语法：Makefile规则语法、伪目标、变量赋值、特殊变量、自动化变量、条件语句和Makefile常用函数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">接着，我们需要提前规划Makefile要实现的功能。一个大型Go项目通常需要实现以下功能：代码生成类命令、格式化类命令、静态代码检查、 测试类命令、构建类命令、Docker镜像打包类命令、部署类命令、清理类命令，等等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">然后，我们还需要通过Makefile功能分类、文件分层、复杂命令脚本化等方式，来设计一个合理的Makefile结构。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">最后，我们还需要掌握一些Makefile编写技巧，例如：善用通配符、自动变量和函数；编写可扩展的Makefile；使用带层级的命名方式，等等。通过这些技巧，可以进一步保证我们编写出一个高质量的Makefile。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>makefile语法</li>
<li>makefile编写技巧</li>
</ul>
<div class="language-makefile codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-makefile codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">include scripts/make-rules/golang.mk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">include scripts/make-rules/image.mk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">include scripts/make-rules/gen.mk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">include scripts/make-rules/...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## build: Build source code for host platform.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.PHONY: build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">build:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@$(MAKE) go.build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.PHONY: build.multiarch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">build.multiarch:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@$(MAKE) go.build.multiarch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## image: Build docker images for host arch.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.PHONY: image</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">image:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@$(MAKE) image.build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## push: Build docker images for host arch and push images to registry.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.PHONY: push</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">push:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@$(MAKE) image.push</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">## ca: Generate CA files for all iam components.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.PHONY: ca</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ca:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@$(MAKE) gen.ca</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">另外，一个合理的Makefile结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好Makefile当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用Makefile编程技巧，编写可扩展的Makefile。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这里需要你注意：上面的Makefile通过 .PHONY 标识定义了大量的伪目标，定义伪目标一定要加 .PHONY 标识，否则当有同名的文件时，伪目标可能不会被执行。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><a href="https://github.com/seisman/how-to-write-makefile" target="_blank" rel="noopener noreferrer">seisman/how-to-write-makefile: 跟我一起写Makefile重制版</a></p>
<p><a href="https://seisman.github.io/how-to-write-makefile/" target="_blank" rel="noopener noreferrer">跟我一起写Makefile — 跟我一起写Makefile 1.0 文档</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BB%BDGo%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84Makefile%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.md" target="_blank" rel="noopener noreferrer">特别放送 给你一份Go项目中最常用的Makefile核心语法</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="golang-spec">golang spec<a href="#golang-spec" class="hash-link" aria-label="golang spec的直接链接" title="golang spec的直接链接">​</a></h3>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>提示</div><div class="admonitionContent_BuS1"><p><a href="/zh-Hans/2024/code-spec">code-spec.md</a></p></div></div>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E3%80%81%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A5%97%E7%94%A8%E7%9A%84Go%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener noreferrer">特别放送 给你一份清晰、可直接套用的Go编码规范</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="用cronredsync自己实现分布式任务调度系统">用cron+redsync自己实现分布式任务调度系统<a href="#用cronredsync自己实现分布式任务调度系统" class="hash-link" aria-label="用cron+redsync自己实现分布式任务调度系统的直接链接" title="用cron+redsync自己实现分布式任务调度系统的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0.md" target="_blank" rel="noopener noreferrer">特别放送 分布式作业系统设计和实现</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="许式伟的架构课读书笔记">《许式伟的架构课》读书笔记<a href="#许式伟的架构课读书笔记" class="hash-link" aria-label="《许式伟的架构课》读书笔记的直接链接" title="《许式伟的架构课》读书笔记的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE" target="_blank" rel="noopener noreferrer">许式伟的架构课</a> 可以看到这本书分为几部分，从6到19是kernel相关，都有点基础了，不看；20到33是桌面client相关，用不到不看；34到46是“服务开发篇”；47到56是“服务治理篇”；57到67是“架构思维篇”；68到77是“软件工程篇”。</p>
<hr>
<p><a href="https://juejin.cn/post/7208188047707340855" target="_blank" rel="noopener noreferrer">许式伟的架构课Day8如何阅读别人的代码为什么要阅读别人的代码 阅读别人代码的目的性: 我要评估是否引入第三方模块 我要 - 掘金</a></p>
<p><a href="https://qiankunli.github.io/2020/11/24/architecture_note.html" target="_blank" rel="noopener noreferrer">《许式伟的架构课》笔记 | 李乾坤的博客</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="服务开发篇-34-46">服务开发篇 (34-46)<a href="#服务开发篇-34-46" class="hash-link" aria-label="服务开发篇 (34-46)的直接链接" title="服务开发篇 (34-46)的直接链接">​</a></h3>
<p><img decoding="async" loading="lazy" alt="network-layer.png" src="/zh-Hans/assets/images/network-layer-2c286da40faa8a53e3f9fb82356d940e.png" width="1920" height="956" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">今天我们从流量调度谈起，聊了几种典型的调度手段和负载均衡的方式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从流量调度角度来说，负载均衡的最大价值是让多个业务服务器的压力均衡。这里面隐含的一个前提是负载均衡软件的抗压能力往往比业务服务器强很多（为什么？欢迎留言讨论）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这表现在：其一，负载均衡的实例数/业务服务器的实例数往往大大小于1；其二，DNS 的调度不均衡，所以负载均衡的不同实例的压力不均衡，有的实例可能压力很大。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当然，负载均衡的价值并不只是做流量的均衡调度，它也让我们的业务服务器优雅升级成为可能。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">那么，桌面程序和服务端程序的差别在哪？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">它们最大的差别是业务状态的表示不同。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">桌面程序的业务状态是如何表示的？内存中的数据结构。我们在上一章中提到，桌面程序的 Model 层是一棵 DOM 树，根结点通常叫 Document。这棵 DOM 树其实就是桌面程序的业务状态。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">服务端程序的业务状态如何表示？用内存中的数据结构可以吗？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">答案当然是不能。如果业务状态在内存中，服务端程序一挂，数据就丢了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">前面我们在 “[34 | 服务端开发的宏观视角]” 提到过：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">坚决不能丢失用户的数据，即他认为已经完成的业务状态。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">服务端对用户来说是个黑盒，既然用户收到某个 “网络API请求” 成功的反馈，那么他会认为这个成功是确认的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以，服务端必须保证其业务状态的可靠性。这与桌面程序不同，桌面程序往往需要明确的用户交互事件，比如 Ctrl+S 命令，来完成数据的存盘操作，这时业务状态才持久化写入到外存。而且对于大部分桌面程序来说，它并不需要支持持久化。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><em><strong>“三高”是BE的基本需求，也是相较于FE的特征。</strong></em></p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">存储即数据结构。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">存储中间件是什么？存储中间件就是 “元数据结构”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这个结论的逻辑在于下面几个方面。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">首先，和桌面开发不同，桌面端的数据结构基本上都是基于内存的，实现难度较低。但是在服务端不同。我们每一次的业务状态改变都需要考虑持久化，所以服务端的核心数据结构都是基于外存的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">其次，服务端的数据结构对稳定性要求、并发性能（IOPS）要求极高。简单分析就可以知道，服务端程序的伸缩能力完全取决于存储的伸缩能力。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">业务服务器往往是无状态的，压力大了新增加一台业务服务器非常容易。但是存储压力大了，并不能简单加一台机器了事，可能涉及数据的重新划分和搬迁工作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这意味着，在服务端实现一个数据结构是非常困难的。我们举一个很简单的例子，在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。就算不用库，我们自己花上几十分钟或一个小时来实现，也是非常轻松的一件事情。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。就算干出来了，也没人敢立刻投入使用，需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。并且，即使敢投入生产环境了，为了以策万全，刚开始往往也是采用“双写”的方式：同时使用一个成熟存储系统和我们新上线的存储。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">存储系统的品控，至关重要。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">存储中间件会有多少？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这与服务端开发的模型抽象有关。今天没有比较系统性的理论告诉大家，有了这样一些数据结构就完备了。但是从更长远发展的角度来看，我们很可能需要回答这个问题。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以，存储中间件是 “元数据结构”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这里说的 “元数据结构”，是我自己发明的一个词。它表达的含义是，数据结构的种类是非常有限的，并且最好理论可被证明，有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。这些基本的数据结构，就是我说的 “元数据结构”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">今天我们接触的存储中间件有哪些？不完整的列表如下：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">键值存储（KV-Storage）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对象存储（Object Storage）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">数据库（Database）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">消息队列（MQ）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">倒排索引（SearchEngine）；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">等等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">目前看，存储中间件的种类是不可枚举的。但它很可能只是受限于我自己的认知，也许有一天我们能够在这个问题上找到更加完美的答案。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>“正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。”</p>
<p>在作者看来，“存储中间件是 “元数据结构””，存储中间件也是一种数据结构，还是“元数据结构”。也就是说，这些“存储中间件”的本质其实就是某种做成了服务的“数据结构”，来进行远程调用。也举出了一些例子，比如说，kvbd其实就是kv，es本质就是倒排索引。这个说法，其实是从数据结构的角度来看各种database，当然，这个观点，也是作者从BE和FE的比较中得来的。</p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">缓存（Cache）和存储（Storage）是什么关系？它也是一种存储中间件么？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">既是也不是。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">首先，缓存和一般的存储中间件一样，也在维持着业务状态。从这个角度看，缓存的确是一类存储。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是，缓存允许数据发生丢失，所以缓存通常是单副本的。一个内存缓存的集群挂了一个实例，或者一个外存缓存的集群坏了一块硬盘，单就缓存集群本身而言，就出现数据丢失。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">回到前面的问题，缓存（Cache）和存储（Storage）到底是什么关系？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我个人认为，缓存其实应该被认为是存储的补丁，而且是理论上来说不太完美的补丁。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为什么说它是补丁？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">因为如果存储本身非常匹配业务场景的话，它不应该需要缓存在它前面挡一道，内部自己就有缓存。至于把一个复杂的 F(x) 缓存起来，更根本的原因还是存储和业务场景不那么直接匹配所致。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是实现一个存储很难，所以存储的业务场景匹配性很难做到处处都很好。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">出现事务（Transaction），是为了改善存储的业务场景“写操作”的匹配性，把一个复杂操作包装成一个原子操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">出现缓存（Cache），则是为了改善存储的业务场景“读操作”的匹配性，提升高频读操作的效率。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以我们说，缓存是一个存储的补丁。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">那么为什么我们说这是一个不太完美的补丁呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">因为上面的 FastF(x) 并没有被包装成一个原子的读操作。从严谨的角度来说，这段代码逻辑是有问题的，它会破坏数据的一致性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于一个确定的 x 值，如果 F(x) 永远不变，这就没问题。但如果 F(x) 值会发生变化，会有多个版本的值，那就有可能会出现并发的两个 F(x) 请求得到的结果不同，从而导致缓存中的值和存储中的值不一致。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这种情况后果有可能会比较严重。尤其是如果我们有一些业务逻辑  是基于 FastF(x) 得到的值，就有可能会出现逻辑错乱。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>“需要cache，归根到底还是因为storage和业务场景本身不匹配造成的”</p>
<p>这个观点太棒了，也确实如此</p>
<p>解答了我之前的一个问题</p>
<p>kvdb 和 local cache 有啥区别</p>
<p>因为</p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">首先，缓存和一般的存储中间件一样，也在维持着业务状态。从这个角度看，缓存的确是一类存储。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是，缓存允许数据发生丢失，所以缓存通常是单副本的。一个内存缓存的集群挂了一个实例，或者一个外存缓存的集群坏了一块硬盘，单就缓存集群本身而言，就出现数据丢失。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">缓存数据丢失，这事可大可小。只要不是发生大片大片的缓存数据丢失的情形，通常只是会造成后端存储（Storage）的短时压力变大。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但在极端的情况下，可能会出现雪崩的情况。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">雪崩怎么形成？首先是部分缓存实例宕机，导致缓存命中率（Cache Hit Rate）下降，大量的请求落到后端存储上，导致后端存储过载，也出现宕机。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这时就会出现连锁反应，形成雪崩现象。后端存储就算重新启动起来，又会继续被巨大的用户请求压垮，整个系统怎么启动也启动不了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">应该怎么应对雪崩？最简单的办法，是后端存储自己要有过载保护能力。一旦并发的请求超过预期，就要丢弃部分请求，以减少压力。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里对cache avalanche的过程描述不错</p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这些都让 Redis 看起来更像一个数据库类的存储中间件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但当我们把 Redis 看作存储，我们有这样一些重要的问题需要考虑。这些问题非常非常重要，存储系统可不是闹着玩的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">问题一，是持久性（Durability）。Redis 毕竟是基于内存的存储，虽然它也支持定期写到外存中，但是定期持久化的策略对于一个服务端的存储系统来说是不合格的。因为如果发生宕机，上一次持久化之后的新数据就丢了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以 Redis 需要其他的提升持久性的方案，比如多副本。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Redis 的确支持多副本。但是只是同机房多台机器的多副本是没有用的，因为它没有办法防止机房整体断电这类的故障。当出现机房级的故障时，就有极大概率会丢失数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于存储系统来说，这是不可接受的。因为相比人们对持久性的要求，机房整体断电并不是一个太小概率的事件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以 Redis 如果要作为存储的话，必须保证用多机房多副本的方式，才能保证在持久性这一点上能够达标。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但是多机房多副本这样的方式，显然实施条件过于苛刻。会有多少企业仅仅是为了部署 Redis 去搞多个机房呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">问题二，是重试的友好  性。在 “[29 | 实战（四）：怎么设计一个“画图”程序？]” 中我们提到过，考虑网络的不稳定性，我们设计网络协议的时候需要考虑重试的友好性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在 Redis 的协议中，有不少请求用户很友好，但是对重试并不友好。比如，LPUSH 请求用来给列表（List）增加一个元素。但是在重试时一个不小心，我们很可能就往列表中添加了多个相同的元素进去。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">总结来说，Redis 如果我们把它作为存储的话，坑还是不少的。它和 memcached 都是实用型的瑞士军刀，很有用，但是我们站在分布式系统的理论角度看时，它们都有那么一点不完美的地方。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这里从分布式系统的角度出发，给redis本身挑了两个错：</p>
<ul>
<li>redis的多副本机制，只能保证同机房，无法保证跨机房。所以如果整个IDC出现问题，那就完蛋了。（当然这种情况的话，数据是不是本身也持久化道本地了，数据本身问题不大，只是服务挂了？）</li>
<li>redis的写操作不支持幂等性？因为list本身就支持添加重复数据啊，相应的，set、zset就不支持添加重复数据。这个是ds本身就要求的。</li>
</ul>
<p>所以，可能这两点其实也不太成立？</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/45%20%e6%9e%b6%e6%9e%84%ef%bc%9a%e6%80%8e%e4%b9%88%e5%81%9a%e8%af%a6%e7%bb%86%e8%ae%be%e8%ae%a1%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">45 架构：怎么做详细设计？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">实现：数据结构+算法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">聊完使用界面，接下来就要谈实现原理了，它要体现的是我如何做到。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在 “[42 | 实战（二）：“画图”程序后端实战]” 一讲中，我们提到过以下这个大家耳熟能详的公式：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">程序 = 数据结构 + 算法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">它是一个很好的指导思想。当我们谈程序的实现时，我们总是从数据结构和算法两个维度去描述它。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我们先看数据结构。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">数据结构从大的层面分，可分为基于内存的数据结构，和基于外存（比如 SSD 盘）的数据结构。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于桌面程序，大部分情况下我们打交道的都是基于内存的数据结构。外存数据结构也会有所涉及，但往往局限于 IO 子系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但对于服务端程序，数据结构不完全是我们自己能够做主的。数据结构大部分情况下都是基于外存的，而且有极高的质量要求。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>程序 = 数据结构 + 算法</p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">在 “[36 | 业务状态与存储中间件]” 这一讲中我们也说过，存储即数据结构。所以，服务端程序在数据结构这一点上，最为重要的一件事是选择合适的存储中间件。然后我们再在该存储中间件之上组织我们的数据。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这是数据库这样的存储中间件流行起来的原因。无论是关系型数据库，还是文档型数据库，他们都被设计为一种泛业务场景的数据结构，有很好的业务适应性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以在服务端我们谈数据结构，谈的不是内存数据结构，往往谈的是数据库的表结构设计。当然表（Table）是在关系型数据库中的说法，在 mongodb 中我们叫集合（Collection）。但不管我们用的是哪种数据库，出于惯例我们往往还是以 “定义表结构” 一词来表达我们想干什么。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">描述表结构，核心需要包含以下内容：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">字段名；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">类型；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">字段含义，以及是否指向另一个表的某个字段；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">索引。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">你会发现，其实定义表结构和定义内存数据结构本质是完全一致的。定义内存中的一个类（或结构体），我们也关心字段名（成员变量名）和类型，也关心字段的含义，以及它是否指向另一个类（或结构体）的某个字段（成员变量）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但表结构比内存数据结构多了一个概念：索引。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">索引为何存在？我认为有这样几方面的原因。一方面是因为数据库是泛业务场景的通用数据结构，它是动态的，需要依赖索引来提升数据访问的效率。另一方面是因为多租户。多租户导致数据量的爆发式增长，导致大部分情况下遍历查找变得不现实。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">索引怎么设计？它完全取决于算法。算法里面使用了哪些数据访问的特征，这些数据访问的频次预期是多少，这些决定了我们添加哪些索引是最划算的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在涉及的类比较多，或数据库的表结构比较复杂的时候，有时我们会用 UML 类图来对数据结构进行直观的呈现。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">谈清楚了数据结构，我们接着聊算法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在 “程序 = 数据结构 + 算法” 这个说法中，“算法” 指的是什么？在 “[42 | 实战（二）：“画图”程序后端实战]” 一讲中，我们这么说：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在架构过程中，需求分析阶段，我们关注用户需求的精确表述，我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是用户故事。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">到了详细设计阶段，角色和用户故事就变成了子系统、模块、类或者函数的使用界面（接口）。我们前面一直在强调，使用界面（接口）应该自然体现业务需求，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也有自然的延续性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以算法，最直白的含义，指的是用户故事背后的实现机制。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">数据结构 + 算法，是为了满足最初的角色与用户故事定义，这是架构的详细设计阶段核心关注点。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>“程序 = 数据结构 + 算法” 是我们很熟悉的一个公式。它其实是怎么描述实现原理的很好的指导方针。当我们谈程序的实现时，我们总是从数据结构和算法两个维度去描述它。</p>
<p>“程序 = 数据结构 + 算法”这一公式被用来指导详细设计的过程。数据结构是程序中数据的组织和存储方式，它决定  了数据如何在系统中被管理，包括在内存中或数据库等外存中的组织形式。算法则是操作这些数据结构的方法和步骤，它定义了如何通过一系列指令来解决问题或完成任务。在详细设计中，设计者需要明确系统的使用界面，即系统或模块如何被其他部分使用，同时也要描述数据如何在系统中流动和被处理，这涉及到选择合适的数据存储结构和定义操作数据的算法。简而言之，程序设计不仅仅是编写代码，更重要的是设计合理的数据结构和高效的算法，以确保程序能够有效地满足业务需求并运行高效。</p>
<p>应该说，这是一个高度抽象的概括。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="服务治理篇-47-56">服务治理篇 (47-56)<a href="#服务治理篇-47-56" class="hash-link" aria-label="服务治理篇 (47-56)的直接链接" title="服务治理篇 (47-56)的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/47%20%e6%9c%8d%e5%8a%a1%e6%b2%bb%e7%90%86%e7%9a%84%e5%ae%8f%e8%a7%82%e8%a7%86%e8%a7%92.md" target="_blank" rel="noopener noreferrer">47 服务治理的宏观视角</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">我们的期望，是把服务治理建立成自治系统，而不是简单的自动化系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">基于这样的思考，人们逐渐建立  了基于物理机器资源的服务治理体系。脚本成为了平台。而平台的形成，正是脚本的抽象化、产品化、普适化的结果。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">把一个服务实例绑定在某一台物理的服务器，虽然让服务视图看起来很直观，但是这种绑定让我们应对物理资源故障变得被动，同时也不利于服务器资源的充分利用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以虚拟机和容器技术的诞生，促使人们开始探索物理资源和应用服务之间的解耦。而一旦我们完成了这一步，服务的逻辑视图就完全语义化了，它与物理资源就只是一个应用的过程。物理资源环境发生任何故障，都可以迅速在新的硬件设备上重新构建。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对 SRE 来说，机器的损坏和生命周期管理基本上已经不需要任何操作了。硬件已经被池化。成千上万的机器加入系统，或者出现问题，被修复，这一切都不需要 SRE 的任何操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这意味着，随着系统的层次结构不断上升，我们完成了从手动触发，到自动触发，到自主化。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title=" 复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/48%20%e4%ba%8b%e5%8a%a1%e4%b8%8e%e5%b7%a5%e7%a8%8b%ef%bc%9a%e4%bb%80%e4%b9%88%e6%98%af%e5%b7%a5%e7%a8%8b%e5%b8%88%e6%80%9d%e7%bb%b4%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">48 事务与工程：什么是工程师思维？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">什么才是真正的工程师文化？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从浅层的意义来说，工程师就是要实现业务的自动化。DON’T REPEAT YOURSELF! 某件重复发生的事情只干一次就好，以后也不需要再重复做。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">工程师的自动化思维，所体现的内在逻辑是如何把问题 Close，如何把问题彻底解决掉，而编码只是一种工具。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在我们日常生活中，很多问题不需要编码来解决，但是确实需要用 “彻底解决它” 的思维去完成。这种思维不仅限于工程师，同样适用于所有人。比如，我们开餐厅需要解决服务质量的问题，这一点可能海底捞就解决得很好，但是不一定是用编码的方式解决。同样地，假设我们办线下市场活动，要解决内容质量的问题。怎么彻底解决它，这是值得深度思考的问题。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">很多人会习惯呆在自己的舒适区，习惯于做任务，每天重复相同的作业，这就不符合我们所说的 “工程师文化”。我们需要达到的状态是，今天干完一件事，明天开启新的事。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">怎么判断自己在做新的事情？那就要看我们问题是否解决得够彻底。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">比如我在做新媒体运营，每天写着不同的公众号文章，这是否代表我在做新的事情？答案显然是不一定。要回答这个问题，我们首先需要搞清楚的是，我每天发公众号文章，是在解决一个什么样的问题。如果我们没有想清楚这一点，那么我们就不是在 Close 问题，我们只是在做任务 而已。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我们的目标显然不应该是每天发一篇文章。这是在定义一件事务，而不是定义一个目标。把问题定义清楚非常非常重要。清楚了问题，就是设定清楚了我们的目标。然后才能谈得上去彻底解决掉它。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从另一个维度看，工程师这种把问题 Close，彻底解决掉的思维，看重的是自己工作内容的长期价值。如果我们只是在做事务，如果我们并没有在实质性解决一个问题，那么这件事情的长期价值就是零。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以本质上，工程师文化也是产品文化，把问题以一种自动化的方式解决。 这才是我们真正应该尊崇的工程师文化。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一个公司各个岗位是彼此协作的团队，工程师并不是特殊群体。销售、技术支持、产品、开发工程师每一个角色都是平等的。每个人都应该秉承工程师精神，把一个个问题 Close，让它不要再发生。不需要显得很忙，忙不代表成就，真正的工程师文化应该是推动整个团队往前走，每个团队成员都在成长。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>“怎么判断自己在做新的事情？那就要看我们问题是否解决得够彻底。”</p>
<p>要 close问题，而不是解决问题</p>
<p><em><strong>其实也就是老生常谈的“更深一步”，fix了bug之后，还要挖掘bug真正的成因在什么地方？哪里的知识点有问题？team的开发规范/工作流程有问题？还是更深层次的团队文化问题？ 解决生活中的问题同样。我觉得这个不是反思，</strong></em></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/52%c2%a0%e6%95%85%e9%9a%9c%e6%8e%92%e6%9f%a5%e4%b8%8e%e6%a0%b9%e5%9b%a0%e5%88%86%e6%9e%90.md" target="_blank" rel="noopener noreferrer">52 故障排查与根因分析</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">从理论上讲，我们将故障排查过程定义为反复采用“假设-验证排除”手段的过程：针对某系统的一些观察结果和对该系统运行机制的理论认知，我们不断提出一个造成系统问题的假设，进而针对这些假设进行测试和排除。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">为了有效排查故障，日志系统在里面起到了关键作用。定位问题本身就是 “假设-验证排除-再假设-再验证排除” 这样的循环，直至最后定位到问题。所以基于时序数据的日志系统，往往查询支持非常多样化的过滤条件，功能非常强大。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/56%20%e6%9c%8d%e5%8a%a1%e6%b2%bb%e7%90%86%e7%af%87%ef%bc%9a%e5%9b%9e%e9%a1%be%e4%b8%8e%e6%80%bb%e7%bb%93.md" target="_blank" rel="noopener noreferrer">56 服务治理篇：回顾与总结</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">服务端的话题被我分为了两章：“服务端开发篇” 与 “服务治理篇”。它们的边界在于，服务端开发致力于设计合适的业务架构来满足用户需求，而服务治理则致力于让服务端程序健康地为客户提供 7x24 小时不间断的服务。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Docker 出现后，紧接着 CoreOS 也推出了新的服务端操作系统。CoreOS 是专注于服务端的操作系统，它认为除了只读的操作系统内核外，所有的软件都应该是基于容器发布的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这种思想很先进。但无奈的是，它一方面对用户习惯改变过大，另一方面也没有真正切中用户最关键的痛点，导致它  一直没能够流行起来。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">从商业角度来说，早期 Docker 和 CoreOS 表现得很互补的样子，但是双方的商业目标其实相同，都是希望能够成为数据中心操作系统（DCOS）的领导者。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以，Docker 推出了 Docker Swarm，而 CoreOS 也有自己的集群版。这下，两家公司的友好协作的表象很快就被打破了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">但最后，Google 牵头推 Kubernetes，结束了 DCOS 之争。当然这事今天来重新回顾，它也在情理之中，毕竟容器技术实际上最早是在 Google 推动下被加入 Linux 内核，而它内部更是有 Borg 这样的 DCOS 系统，有着丰富的基于容器的服务治理实践经验。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">无论是 Docker 还是 CoreOS，两家公司都大大低估了 DCOS 这件事情的难度。当然这事低估的并不只是他们，也包括七牛云。在 Docker 诞生后，我们就意识到 DCOS 是未来，所以 2014 年我们就成立了 QCOS 项目组来做这事，但最终这个项目组转向了拥抱 Kubernetes。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>CoreOS 是专注于服务端的操作系统，它认为除了只读的操作系统内核外，所有的软件都应该是基于容器发布的。</p>
<p><img decoding="async" loading="lazy" alt="service-governance.png" src="/zh-Hans/assets/images/xsw-chapter-4-0e7db23d9f149a9c9e4dd129616a4ecc.png" width="1326" height="884" class="img_ev3q"></p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">今天我们对本章内容做了概要的回顾，到此为止，我们 “基础平台”、“桌面开发”、“服务端开发”、“服务治理” 这四大模块就结束了。从工程师架构设计角度来说，它们基本上涵盖了我们会打交道的绝大部分通用业务场景。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">理解了这几章的内容，整个软件大厦的骨架就可以明了了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">下一步应该学什么？  架构思维原则？或者是设计模式？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">架构思维的确是有很多共性的东西，值得我们总结出来细细体会。比如 “开闭原则”，多么有力的架构思维的总结，值得我们时时拿出来提醒自己。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">不过，我个人不太喜欢常规意义上的 “设计模式”。或者说，我们对设计模式常规的打开方式是有问题的。理解每一个设计模式，都应该放到它想要解决的问题域来看。所以，我个人更喜欢的架构范式更多的是 “设计场景” 的总结。“设计场景” 和设计模式的区别在于它有自己清晰的问题域定义，是一个实实在在的通用子系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">是的，这些 “通用的设计场景”，才是架构师真正的武器库。如果我们架构师总能把自己所要解决的业务场景分解为多个 “通用的设计场景” 的组合，这就代表架构师有了极强的架构范式的抽象能力。而这一点，正是架构师成熟度的核心标志。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="架构思维篇-57-67">架构思维篇 (57-67)<a href="#架构思维篇-57-67" class="hash-link" aria-label="架构思维篇 (57-67)的直接链接" title="架构思维篇 (57-67)的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/58%c2%a0%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e7%9a%84%e4%bc%98%e5%8a%a3%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">58 如何判断架构设计的优劣？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">架构设计的基本准则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">架构设计会有它的一些基本准则。比如：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KISS：简单比复杂好；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Modularity：着眼于模块而不是框架；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Testable：保证可测试性；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Orthogonal Decomposition：正交分解。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KISS 全称是 Keep it Simple, Stupid，用最直白的话说，“简单就是美”。不增加无谓的复杂性。正确理解系统的需求之后才进行设计。要避免过度设计，除非有人为复杂性买单。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KISS 的“简单”，强调的是易实施性。让模块容易实现，实现的时候心智负担低，比复杂的优化更重要。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">KISS 的“简单”，也是主张让你的代码，包括接口，符合惯例。接口语义要自然，最好让人一看方法名就知道怎么回事，避免惊异。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Modularity，强调的是模块化。从架构设计角度来说，模块的规格，也就是模块的接口，比模块的实现机制更重要。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">我们应着眼于模块而不是框架。框架是易变的。框架是业务流，可复用性相对更低。框架都将经历不断发展演化的过程，逐步得到完善。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">所以不让模块为框架买单。模 块设计时应忽略框架的存在。认真审视模块的接口，发现其中“过度的（或多余的）” 约束条件，把它提高到足够通用的、普适的场景来看。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Testable，强调的是模块的可测试性。设计应该以可测试性为第一目标。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可测试往往意味着低耦合。一个模块可以很方便地进行测试，那么就可以说它是一个设计优良的模块。模块测试的第一步是环境模拟。模块依赖的模块列表、模块的输入输出，这些是模块测试的需要，也是模块耦合度的表征。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当然，可测试性不单单因为是耦合的需要。测试让我们能够发现模块构架调整的潜在问题。通常模块在架构调整期（代码重构）最容易引入 Bug。 只有在模块开发过程中我们就不断积累典型的测试数据，以案例的形式固化所有已知 Bug，才可能在架构调整等最容易引发问题的情形下获得最佳的效果。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Orthogonal Decomposition，中文的意思是 “正交分解”。架构就是不断地对系统进行正交分解的过程。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">相信大家都听过一个设计原则：“优先考虑组合，而不是继承”。如果我们用正交分解的角度来诠释这句话，它本质上是鼓励我们做乘法而不是做加法。组合是乘法，它是让我们用相互正交、完全没有相关性的模块，组合出我们要的业务场景。而继承是加法，通过叠加能力把一个模块改造成另一个模块。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><em><strong>架构设计的基本准则：KISS, 模块化、可测试、正交性</strong></em></p>
<p>需要注意的是，这里的模块化，指的是“应该着眼于模块，而不是框架”。按我的理解，各种pkg其实就可以看作是某种“模块化”的实践。但是，除此之外，各种业务代码本身就是与项目耦合的，恐怕很难模块化吧？还是说微服务也可以看作是该准则的实践？</p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">核心系统的伤害值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">正交分解，第一件事情就是要分出哪些是核心系统，哪些是周边子系统。核心系统构成了业务的最小功能集，而后通过不断增加新的周边功能，而演变成功能强大的复杂系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于核心系统的变更要额外小心。如果某新功能早期没有规划，后期却被界定为属于核心功能，我们就需要认真评估它对既有架构的破坏性。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="chapter-4.png" src="/zh-Hans/assets/images/xsw-chapter-4-0e7db23d9f149a9c9e4dd129616a4ecc.png" width="1326" height="884" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="软件工程篇-68-77">软件工程篇 (68-77)<a href="#软件工程篇-68-77" class="hash-link" aria-label="软件工程篇 (68-77)的直接链接" title="软件工程篇 (68-77)的直接链接">​</a></h3>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/70%20%e6%80%8e%e4%b9%88%e5%86%99%e8%ae%be%e8%ae%a1%e6%96%87%e6%a1%a3%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">70 怎么写设计文档？</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/71%c2%a0%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%e5%88%ab%e4%ba%ba%e7%9a%84%e4%bb%a3%e7%a0%81%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">71 如何阅读别人的代码？</a></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<p>传道授业。许式伟这本书更多传达出的是，作为架构师，应该怎么思考，倒不涉及太多真正技术细节相关的东西。也就是更多是“传道”，而非“授业”。这在现在各种“教程类”的技术书里，也是独树一帜了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="架构设计面试精讲">《架构设计面试精讲》<a href="#架构设计面试精讲" class="hash-link" aria-label="《架构设计面试精讲》的直接链接" title="《架构设计面试精讲》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2" target="_blank" rel="noopener noreferrer">架构设计面试精讲</a> 没啥意思，3到8是分布式系统相关问题；9到12是mysql相关；13、14是redis相关；15到19是一些面试中系统设计相关问题</p>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="分布式系统-3-8">分布式系统 (3-8)<a href="#分布式系统-3-8" class="hash-link" aria-label="分布式系统 (3-8)的直接链接" title="分布式系统 (3-8)的直接链接">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="系统设计-15-19">系统设计 (15-19)<a href="#系统设计-15-19" class="hash-link" aria-label="系统设计 (15-19)的直接链接" title="系统设计 (15-19)的直 接链接">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="总结-1">总结<a href="#总结-1" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h3>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="从-0-开始学架构"><del>《从 0 开始学架构》</del><a href="#从-0-开始学架构" class="hash-link" aria-label="从-0-开始学架构的直接链接" title="从-0-开始学架构的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener noreferrer">从 0 开始学架构</a> 快速过了一下，内容都是浅尝辄止，所以跳读查缺补漏一下</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/24%20FMEA%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%92%E9%99%A4%E6%9E%B6%E6%9E%84%E5%8F%AF%E7%94%A8%E6%80%A7%E9%9A%90%E6%82%A3%E7%9A%84%E5%88%A9%E5%99%A8.md" target="_blank" rel="noopener noreferrer">24 FMEA方法，排除架构可用性隐患的利器</a></p>
<p>FEMA = Failure mode and effects analysis</p>
<p>故障模式与影响分析</p>
<p>在软件架构设计中，怎么实践FMEA？都有哪些步骤？</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/19%20%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E6%80%A7%E8%83%BD%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor%E4%B8%8EProactor.md" target="_blank" rel="noopener noreferrer">19 单服务器高性能模式：Reactor与Proactor</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/23%20%E6%83%B3%E6%88%90%E4%B8%BA%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84CAP%E7%BB%86%E8%8A%82.md" target="_blank" rel="noopener noreferrer">23 想成为架构师，你必须掌握的CAP细节</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="周志明的架构课"><del>《周志明的架构课》</del><a href="#周志明的架构课" class="hash-link" aria-label="周志明的架构课的直接链接" title="周志明的架构课的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%91%A8%E5%BF%97%E6%98%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE" target="_blank" rel="noopener noreferrer">周志明的架构课</a></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="高并发系统设计40问"><del>《高并发系统设计40问》</del><a href="#高并发系统设计40问" class="hash-link" aria-label="高并发系统设计40问的直接链接" title="高并发系统设计40问的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE" target="_blank" rel="noopener noreferrer">高并发系统设计40问</a></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="由浅入深吃透-docker"><del>《由浅入深吃透 Docker》</del><a href="#由浅入深吃透-docker" class="hash-link" aria-label="由浅入深吃透-docker的直接链接" title="由浅入深吃透-docker的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%90%83%E9%80%8F%20Docker-%E5%AE%8C" target="_blank" rel="noopener noreferrer">由浅入深吃透 Docker-完</a> 看的时候才发现很久之前看过，实际上这本册子就是从 docker官方文档里摘录出来的，初学者可以看看</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="深入浅出-docker-技术栈实践课"><del>《深入浅出 Docker 技术栈实践课》</del><a href="#深入浅出-docker-技术栈实践课" class="hash-link" aria-label="深入浅出-docker-技术栈实践课的直接链接" title="深入浅出-docker-技术栈实践课的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Docker%20%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5%E8%AF%BE%EF%BC%88%E5%AE%8C%EF%BC%89" target="_blank" rel="noopener noreferrer">深入浅出 Docker 技术栈实践课（完）</a> 太水了</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="容器实战高手课"><del><em><strong>《容器实战高手课》</strong></em></del><a href="#容器实战高手课" class="hash-link" aria-label="容器实战高手课的直接链接" title="容器实战高手课的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE" target="_blank" rel="noopener noreferrer">容器实战高手课</a> 本书的核心是</p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">00 开篇词 一个态度两个步骤，成为容器实战高手.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">01 认识容器：容器的基本操作和实现原理.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">02 理解进程（1）：为什么我在容器中不能kill 1号进程？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">03 理解进程（2）：为什么我的容器里有这么多僵尸进程？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">04 理解进程（3）：为什么我在容器中的进程被强制杀死了？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">05 容器CPU（1）：怎么限制容器的CPU使用？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">06 容器CPU（2）：如何正确地拿到容器CPU的开销？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">07 Load Average：加了CPU Cgroup限制，为什么我的容器还是很慢？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">08 容器内存：我的容器为什么被杀了？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">09 Page Cache：为什么我的容器内存使用量总是在临界点.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 Swap：容器可以使用Swap空间吗？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 容器文件系统：我在容器中读写文件怎么变慢了？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 容器文件Quota：容器为什么把宿主机的磁盘写满了？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 容器磁盘限速：我的容器里磁盘读写为什么不稳定_.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 容器中的内存与IO：容器写文件的延时为什么波动很大？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 容器网络：我修改了_proc_sys_net下的参数，为什么在容器中不起效？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 容器网络配置（1）：容器网络不通了要怎么调试.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 容器网络配置（2）：容器网络延时要比宿主机上的高吗.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 容器网络配置（3）：容器中的网络乱序包怎么这么高？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 容器安全（1）：我的容器真的需要privileged权限吗.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 容器安全（2）：在容器中，我不以root用户来运行程序可以吗？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐01 案例分析：怎么解决海量IPVS规则带来的网络延时抖动问题？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐02 理解perf：怎么用perf聚焦热点函数？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐03 理解ftrace（1）：怎么应用ftrace查看长延时内核函数？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐04 理解ftrace（2）：怎么理解ftrace背后的技术tracepoint和kprobe？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐05 eBPF：怎么更加深入地查看内核中的函数？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">加餐06 BCC：入门eBPF的前端工具.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">结束语 跳出舒适区，突破思考的惰性.md</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><a href="https://github.com/chengyli/training" target="_blank" rel="noopener noreferrer">chengyli/training</a> 这个教程的对应repo</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%ae%b9%e5%99%a8%e5%ae%9e%e6%88%98%e9%ab%98%e6%89%8b%e8%af%be/02%20%e7%90%86%e8%a7%a3%e8%bf%9b%e7%a8%8b%ef%bc%881%ef%bc%89%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%b8%8d%e8%83%bdkill%201%e5%8f%b7%e8%bf%9b%e7%a8%8b%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">02 理解进程（1）：为什么我在容器中不能kill 1号进程？</a> 我知道容器内不能kill掉init进程，如果想重启k8s pod的话，应该用 kubectl rollout restart</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%ae%b9%e5%99%a8%e5%ae%9e%e6%88%98%e9%ab%98%e6%89%8b%e8%af%be/03%20%e7%90%86%e8%a7%a3%e8%bf%9b%e7%a8%8b%ef%bc%882%ef%bc%89%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e7%9a%84%e5%ae%b9%e5%99%a8%e9%87%8c%e6%9c%89%e8%bf%99%e4%b9%88%e5%a4%9a%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">03 理解进程（2）：为什么我的容器里有这么多僵尸进程？</a></p>
<div class="theme-admonition theme-admonition-danger admonition_xJq3 alert alert--danger"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>危险</div><div class="admonitionContent_BuS1"><p>用不到，暂时不看</p></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="csapp以及深入浅出计算机组成原理">《csapp》以及《深入浅出计算机组成原理》<a href="#csapp以及深入浅出计算机组成原理" class="hash-link" aria-label="《csapp》以及《深入浅出计算机组成原理》的直接链接" title="《csapp》以及《深入浅出计算机组成原理》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86" target="_blank" rel="noopener noreferrer">深入浅出计算机组成原理</a></p>
<hr>
<p><img decoding="async" loading="lazy" alt="csapp.png" src="/zh-Hans/assets/images/csapp-40b55fc0954d75a3061134f9e0bb5471.png" width="3172" height="1594" class="img_ev3q"></p>
<p><a href="https://willendless.github.io/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2021/06/29/csapp-ch5/" target="_blank" rel="noopener noreferrer">CSAPP 第五章 优化程序性能（一）基础优化与依赖机器架构的优化 | JR&#x27;s Blog</a></p>
<p><a href="https://willendless.github.io/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2021/06/29/csapp-ch5/" target="_blank" rel="noopener noreferrer">CSAPP 第五章 优化程序性能（一）基础优化与依赖机器架构的优化 | JR&#x27;s Blog</a></p>
<p><a href="https://developer.aliyun.com/article/396481" target="_blank" rel="noopener noreferrer">优化程序性能的几个方法（来自于《深入理解计算机系统》）-阿里云开发者社区</a></p>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">qs</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> “三高架构”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span><br></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">        高并发：</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token important">*扩容*</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 无状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 拆分</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 服务化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 消息队列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 数据异构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 缓存银弹</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 并发化（异步并发）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 连接池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 线程池</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 分布式任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        高可用：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 系统高可用的核心是`备份 + 自动切换`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 如果压力（不只是数据库或者服务器，各个层的压力）太大，考虑做“集群”，所以，也可以认为是`集群 + 自动切换`，核心思想是“去单点”，只不过是机器多少的问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事前：副本；隔离；配额，提前预案，探知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事发：监控和报警</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事中：降级，回滚，应急预案，fairXXX 系列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事后：复盘，思考，技改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `熔断`，通过隔离实现故障隔离</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `降级`，通过降级实现部分可用，有损服务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `回滚`，通过回滚机制快速修复错误版本</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `限流`，通过“限流”保护服务受到雪崩的影响</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `切流量`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `兜底容灾`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 怎么理解DDD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 一般 ddd 会划分几个领域，核心域 (核心业务），通用域 (比如用户中心），支撑域 (比如 MySQL REDIS KAFKA)，ddd 最难的应该就是核心域的服务拆分，但是不管怎么拆分每个服务一般都有自己的缓存 (Redis），持久化 (mySQL)，事件（katka)，服务与服务之间一般通过事件做通信</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;***分布式场景常见问题：分布式场景下的`分布式事务`，`幂等控制`，`异步消息乱序`，和`补偿方案`等问题？***&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span><br></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">        目前的主流方案是 *`待处理内容写入本地表`+`事务外实时触发`+`定时调度补偿`* ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 分布式事务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事务中直接 RPC 调用达到强一致性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 事务中进行异步消息推送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 解决方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 目前我们使用的解决方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 幂等控制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 异步消息乱序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 异步消息结合状态驱动</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 补偿方案</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `HTTP同步调用的补偿`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> `异步消息消费失败的补偿`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 如何解决时间漂移问题在多处理器系统、分布式系统中带来的时序相关的问题？在分布式系统中，怎么使用逻辑时钟和向量时钟？这两种方案做个比较。哪种方法更好呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">u</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> https</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//www.hitzhangjie.pro/blog/2021</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">03</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">09</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">%E8%81%8A%E8%81%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 分布式数据库、分布式锁等场景使用向量时钟。向量时钟相比逻辑时钟更加复杂。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> most common problems in distributed scenarios</span><span class="token punctuation" style="color:#393A34">?</span><span class="token plain"> How to resolve</span><span class="token punctuation" style="color:#393A34">?</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> distributed transactions</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> idempotent control</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> async msg out</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">of</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">order</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> compensation schemes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;***分布式场景下的分布式事务，幂等控制，异步消息乱序，和补偿方案等问题？***&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 目前的主流方案是 </span><span class="token important">*`待处理内容写入本地表`+`事务外实 时触发`+`定时调度补偿`*</span><span class="token plain"> ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 服务治理（包括但不限于：限流，熔断、负载、监控、鉴权、服务发现和注册等等）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">q</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 服务容错（失败切换（failover），失败通知（failback），失败缓存（failcache）， 快速失败（failfast）、双发 backuprequest）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">x</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span><br></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">        服务容错的常用手段：</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">#FailOver 失败自动切换</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试次数。要求服务调用幂等，不管调用多少次，只要是同一个调用，返回结果必须相等，适合读请求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">#FailBack 失败通知</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        消费者调用失败后，不再重试。而是根据失败的详细信息，决定后续的执行策略。对于非幂等的调用场景，不能重试，而是应该查询服务端状态，看调用到底是否实际生效。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">#FailCache 失败缓存</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        服务消费者调用失败或者超时后，不立即重试，而是间隔一段时间再次尝试发起调用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic">#FailFast 快速失败</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        消费者调用一次失败后，不再重试。一般非核心业务调用，采用快速失败，记录日志后就返回。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        一般幂等的使用FailOver或者FailCache，不是幂等调用选择FailBack或者FailFast。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>为什么很多分布式系统都是以DAG（Directed acyclic graph ）实现运算的？</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="分布式中间件实践之路"><del>《分布式中间件实践之路》</del><a href="#分布式中间件实践之路" class="hash-link" aria-label="分布式中间件实践之路的直接链接" title="分布式中间件实践之路的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89" target="_blank" rel="noopener noreferrer">分布式中间件实践之路（完）</a></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="分布式技术原理与实战45讲"><em><strong>《分布式技术原理与实战45讲》</strong></em><a href="#分布式技术原理与实战45讲" class="hash-link" aria-label="分布式技术原理与实战45讲的直接链接" title="分布式技术原理与实战45讲的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C" target="_blank" rel="noopener noreferrer">分布式技术原理与实战45讲-完</a> 1-6是分布式基础；7-13是分布式事务；14-22是分布式服务；23-29是分布式存储；30-37是MQ；38-44是分布式缓存；44-52是分布式高可用</p>
<p><img decoding="async" loading="lazy" alt="distributed-system.png" src="/zh-Hans/assets/images/distributed-system-9bdee5e02cc5f17521eeec0d1d0c1f50.png" width="1235" height="1058" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">本课程分为 7 个模块，共 45 讲。我将从实际工作和面试出发，从分布式理论开始带你建立知识框架，然后逐个攻破分布式技术的各个核心技术领域。为了让你更清晰地了解本课程中的所有知识点，我还准备了一份思维导图：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布式 基础：扎实的理论是进一步学习分布式知识的钥匙，这一模块将详解分布式的概念，包括 CAP 和 Base 理论、各种数据一致性模型，以及两阶段和三阶段提交协议等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布式事务：在电商、金融等业务中都涉及资金往来，事务非常重要，那么分布式事务如何解决、分布式锁如何实现、……，这一模块将会解答。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布式服务：分布式服务是微服务架构的必要条件，这一模块将讲解如何解决服务拆分后的一系列问题，比如 RPC、网关、注册中心等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布式存储：系统架构拆分以后，存储层面的拆分同样重要，数据库层涉及读写分离、分库分表等，这一模块我们来一起来探究这些技术的原理，以及如何在业务中落地。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">消息队列：消息中间件是分布式系统架构的整合剂，这一模块将分享消息队列使用的常见问题，比如重复消费、消息时序等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布  式缓存： 缓存的高性能在分布式系统中发挥了更加重要的作用，那么分布式缓存有哪些分类，以及有哪些经典问题，这一模块我们来一起探究。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">分布式高可用：高可用是工程师始终追求的目标，最后这个模块，我将会为你分享在分布式系统中如何保障系统可用性，如何做好系统监控和限流降级。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="24讲吃透分布式数据库">《24讲吃透分布式数据库》<a href="#24讲吃透分布式数据库" class="hash-link" aria-label="《24讲吃透分布式数据库》的直接链接" title="《24讲吃透分布式数据库》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C" target="_blank" rel="noopener noreferrer">24讲吃透分布式数据库-完</a> 7到12是存储引擎相关，13到23是“模块三”</p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">基于以上设计思路，我把课程分为 4 个模块，合计 24 讲。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">模块一，分布式数据历史演变及其核心原理。从历史背景出发，讲解了分布式数据库要解决的问题、应用场景，以及核心技术特点。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">模块二，分布式数据库的高性能保证——存储引擎。这是专栏的亮点内容，简要展示了现代数据库的存储引擎，比如典型存储引擎、分布式索引、数据文件与日志结构存储、事务处理。其中，我会特别介绍分布式数据库与传统数据库在存储层面上的差异。学完之后，你会对分布式数据库中的重要特性（如一致性和分布式事务）有一个完整的理解，明白为什么一些特定存储引擎（如日志结构存储）更适合去构建分布式数据库。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">模块三，分布式数据库的高扩展性保证——分布式系统。详细介绍分布式数据库中所蕴含的系统设计原理、算法等，包含但不限于错误侦测、领导选举、数据可靠传播、分布式事务、共识算法等内容。虽然分布式内容很多，但我不会面面俱到，而是帮你提炼精华，基于实例为你建立知识体系。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">模块四，知识拓展。我会 和你探讨当代最成功的分布式数据库（传统&amp;新型），探讨它们成功的关键，同时将它们与之前模块中所介绍的技术原理进行相应的映射，让你的知识体系更加丰富。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p>存储引擎这部分，以下两个视频说的更清晰</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=9XtACKzFIRc" target="_blank" rel="noopener noreferrer">#115 理论结合实践详解 B+ 树存储引擎（InnoDB、BoltDB、BuntDB） - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=adamqSuHHck" target="_blank" rel="noopener noreferrer">#116 理论结合实践详解 lsm 树存储引擎（bitcask、moss、leveldb 等） - YouTube</a></li>
</ul>
<p>这里说下我对这部分内容的总结</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="300分钟吃透分布式缓存">《300分钟吃透分布式缓存》<a href="#300分钟吃透分布式缓存" class="hash-link" aria-label="《300分钟吃透分布式缓存》的直接链接" title="《300分钟吃透分布式缓存》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/300%E5%88%86%E9%92%9F%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%AE%8C" target="_blank" rel="noopener noreferrer">300分钟吃透分布式缓存-完</a></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="elasticsearch知识体系详解">《ElasticSearch知  识体系详解》<a href="#elasticsearch知识体系详解" class="hash-link" aria-label="《ElasticSearch知识体系详解》的直接链接" title="《ElasticSearch知识体系详解》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ElasticSearch%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener noreferrer">ElasticSearch知识体系详解</a></p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="etcd实战课">《etcd实战课》<a href="#etcd实战课" class="hash-link" aria-label="《etcd实战课》的直接链接" title="《etcd实战课》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/etcd%E5%AE%9E%E6%88%98%E8%AF%BE" target="_blank" rel="noopener noreferrer">etcd实战课</a></p>
<p><img decoding="async" loading="lazy" alt="etcd.jpg" src="/zh-Hans/assets/images/etcd-qs-b2d8f199b927db2f078934c692a2c170.jpg" width="5378" height="2217" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="etcd-k.jpg" src="/zh-Hans/assets/images/etcd-k-b94bf51a43174991dc145e439278c51f.jpg" width="3920" height="2495" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="etcd-practice.jpg" src="/zh-Hans/assets/images/etcd-practice-ea4addb8c14672ac2481781a0737d980.jpg" width="3912" height="2990" class="img_ev3q"></p>
<hr>
<p><a href="https://kimi.moonshot.cn/chat/crmo515fc7u9ac67qf70" target="_blank" rel="noopener noreferrer">Kimi.ai - 帮你看更大的世界</a> etcd</p>
<p><a href="https://www.cms365.cn/topic/clw8xqqg247uqaz6xj9lrvrbt" target="_blank" rel="noopener noreferrer">etcd-面试题库-创脉思面试题库</a></p>
<p><a href="https://blog.csdn.net/weixin_41605937/article/details/121920094" target="_blank" rel="noopener noreferrer">Etcd——大厂面试问题集合_etcd面试题-CSDN博客</a></p>
<p>etcd Linearizable Read</p>
<p><a href="https://doczhcn.gitbook.io/etcd/index-1/kv_service/put" target="_blank" rel="noopener noreferrer">Put方法 | etcd官 方文档中文版</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="后端技术面试38讲">《后端技术面试38讲》<a href="#后端技术面试38讲" class="hash-link" aria-label="《后端技术面试38讲》的直接链接" title="《后端技术面试38讲》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%9538%E8%AE%B2" target="_blank" rel="noopener noreferrer">后端技术面试38讲</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="深入理解-sentinel">《深入理解 Sentinel》<a href="#深入理解-sentinel" class="hash-link" aria-label="《深入理解 Sentinel》的直接链接" title="《深入理解 Sentinel》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89" target="_blank" rel="noopener noreferrer">深入理解 Sentinel（完）</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/03%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%20Sentinel%EF%BC%8CSentinel%20%E4%B8%8E%20Hystrix%20%E7%9A%84%E5%AF%B9%E6%AF%94.md" target="_blank" rel="noopener noreferrer">03 为什么选择 Sentinel，Sentinel 与 Hystrix 的对比</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="程序员的个人财富课">《程序员的个人财富课》<a href="#程序员的个人财富课" class="hash-link" aria-label="《程序员的个人财富课》的直接链接" title="《程序员的个人财富课》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%B4%A2%E5%AF%8C%E8%AF%BE" target="_blank" rel="noopener noreferrer">程序员的个人财富课</a></p>
<p><em><strong><a href="https://github.com/wzhe06/SmartInvest" target="_blank" rel="noopener noreferrer">wzhe06/SmartInvest: Smart Investing Examples</a></strong></em> 对应的repo，提供了 投资跟踪表 等模板</p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">00 开篇词 为什么说程序员最适合学财富管理？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">01 财富框架：建立属于你自己的财富双塔.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">02 个人发展：你自己的发展才是最大的财富源泉.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">03 理财金字塔：如何建立稳固的投资理财结构？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">04 实战知识：有哪些收益稳健的经典资产配置组合？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">05 支点投资法：主动投资是讲逻辑的！.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">06 不当韭菜：在财富管理的过程中摆正心态，知己知彼.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">07 职业方向：如何选择一个有前景的职业方向？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">08 职业规划：大公司VS小公司，怎样选择更有前途？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">09 期权股权：如何正确处理公司的期权、股权？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 跳槽涨薪：如何规划一条合理的职业道路？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 财富拓展：35岁失业？程序员如何拓宽财富渠道？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 房产投资：如何做出理性的买房决策？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 实战知识：让我们编程计算下怎么还房贷最合适.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 基金投资：如何让专业人士帮你赚钱？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 实战知识：如何选出一只优质的基金？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 股票投资：最适合散户的股票投资方法是什么？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 投资闭环：如何成为越来越专业的投资者？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 技术优势：程序员如何用技术超越其他投资者？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 量化投资：典型的量化投资系统都包含哪些模块？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 价值投资：永远不过时的中长期投资策略.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 趋势跟踪：怎样跟着趋势一起赚钱？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 轮动策略：如何踩准市场变换的节奏？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 对冲思想：这个世界上有稳赚不赔的生意吗？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 多因子模型：整合不同策略，形成合力的顶层框架.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 机器学习：我们能用机器学习来建立投资模型吗？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 量化实战：从0到1搭建起一套简单的量化投资系统（上）.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 量化实战：从0到1搭建起一套简单的量化投资系统（下）.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">番外一 王喆对话李腾：程序员对基金经理的灵魂十问（上）.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">番外三 有哪些能够持续学习的参考资料和相关网站？.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">番外二 王喆对话李腾：程序员对基金经理的灵魂十问（下）.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">番外四 知识总结：这门课的全部思维导图.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">答疑课堂（一） 财富框架篇、个人发展篇思考题集锦.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">答疑课堂（二） 投资实战篇、投资进阶篇思考题集锦.md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">结束语 知行合一：财富管理是一生的事情.md</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><img decoding="async" loading="lazy" alt="wealth-types.jpg" src="/zh-Hans/assets/images/wealth-types-c4ea6bfe4cae3215d580be174a0ecd04.jpg" width="2248" height="1633" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">有的同学可能会说了，这还用问吗？“财富”当然就是我们拥有的金钱了。我曾经也有类似的想法，但直到十年前我读了《富爸爸，穷爸爸》这本书，才知道自己的“格局小了”。财富的定义远远不限于金钱，而是任何有价值，能产生收入的东西，《富爸爸，穷爸爸》中，把一个人的财富归为了下面几大类：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">不需本人到场就可以正常运作的业务；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">股票；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">债券；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">能够产生收入 的房地产；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">版税，如音乐、图书、专利等；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">其他任何有价值、可产生收入，或者有增值潜力，并且有很好销路的东西，比如艺术品。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这本书不仅改变了我对“财富”定义的认识，更重要的是让我明白了这一点：人生在世，最重要的事情不是打工赚工资，而是积累真正的财富。想清楚这个，你才能实现从“打工者思维”到“财富管理者思维”的转变，才有可能真正走上“财富自由”的道路。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>需要注意的是，这里的个人发展和投资理财，跟我们常说的主动收入和被动收入，并不完全相同。</p>
<p>比如说个人发展这栏里，技术课程、影响力变现、所在公司期权，这些其实都属于被动收入。</p>
<p>当然，对我们绝大部分人来说，我们也没有这三样东西，所以也可以笼统地认为是差不多的东西。<em><strong>所以这章的内容就是说，要两只腿走路，主动收入和被动收入，都要转起来  ，飞轮才能越转越快。在现在这个时代，但凡其中一个熄火，都可能要吃点苦头了。但是其中，主动收入是根本，没有主动收入，就不可能有太好的被动收入。</strong></em></p>
<p>这里再插一句，也有观点认为，“被动收入”这种想法是错误的。因为投资赚到了钱，本身就是对认知和决策的一种奖赏（或者说变现），也是付出了精力、忍耐等优秀品质的。并不是躺到床上，没有自己去搬砖、打螺丝、写代码，付出体力劳动，赚到的钱就是“被动收入”。所以从认知的角度出发，不应该认为是“被动收入”，否则会从轻视这份付出，从而未来付出惨痛的代价。</p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">所有的投资标的可以分为四大类：固收类、股票类、实物类、新兴类。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">要尽力了解所有的投资标的大类，设置观察仓就是很好的了解新标的的方法。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在做资产配置时，要遵循层级迭代式投资法，自顶向下地规划你的投资行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">记住永久组合的投资比例：25%股票，25%债券，25%黄金，25%货基。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">要时刻关注自己的大类资产是否存在失衡的情况，如果有，就要制定切实的计划去进行资产再平衡。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><em><strong><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%B4%A2%E5%AF%8C%E8%AF%BE/04%20%E5%AE%9E%E6%88%98%E7%9F%A5%E8%AF%86%EF%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B6%E7%9B%8A%E7%A8%B3%E5%81%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE%E7%BB%84%E5%90%88%EF%BC%9F.md" target="_blank" rel="noopener noreferrer">04 实战知识：有哪些收益稳健的经典资产配置组合？</a></strong></em></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">最经典、极易操作的“股债组合”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">风险更加可控的“风险平价组合”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">可以盲投一辈子的“永久组合”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">标的丰富、业绩卓越的“耶鲁组合”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="theme-admonition theme-admonition-danger admonition_xJq3 alert alert--danger"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>危险</div><div class="admonitionContent_BuS1"><div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 资产配置失衡，具体怎么操作“资产再平衡”？多久评估一次？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 有哪些收益稳健的经典资产配置组合？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 货基指数是一个优于耶鲁组合的投资方案吗？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 货基指数的夏普率为什么这么高呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> 如果让你去选择资产配置的方案，你是会选择货基指数还是耶鲁组合呢？</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/05%20%e6%94%af%e7%82%b9%e6%8a%95%e8%b5%84%e6%b3%95%ef%bc%9a%e4%b8%bb%e5%8a%a8%e6%8a%95%e8%b5%84%e6%98%af%e8%ae%b2%e9%80%bb%e8%be%91%e7%9a%84%ef%bc%81.md" target="_blank" rel="noopener noreferrer">05 支点投资法：主动投资是讲逻辑的！</a></p>
<p><img decoding="async" loading="lazy" alt="wealth-pivot-investment-method.jpg" src="/zh-Hans/assets/images/wealth-pivot-investment-method-302f933eba2b98b44fdbb9f13e605a68.jpg" width="2248" height="1076" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">支点投资法主要分为三个阶段，分别是“建仓阶段”“验证阶段”和“退出阶段”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">“建仓阶段”的主要任务是寻找这次投资行为的逻辑支点，然后根据这个支点，触发相应的投资行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">“验证阶段”则是要不断验证你的投资支点，如果支点的逻辑还成立，就持续持有当前投资标的；如果支撑投资支点的条件已经不存在了，那么就证明当初的投资行为已经没有支撑了，就要进入投资的退出阶段。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">最后的“退出阶段”，需要的是你坚定的执行力，不管该次投资是盈利，还是亏损，只要投资支点不存在了，都应该坚定不移地退出。退出时如果你处于盈利状态，就是“止盈退出”，这次投资行为就是成功的。而如果处于亏损状态，就是“止损退出”，这次投资行为虽然失败了，但由于你清楚地知道亏损的理由是什么，这次投资过程就成为了提升投资水平的宝贵经验。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这是一次完整的应用支点投资法的投资行为。希望你能够对照支点投资法的流程图，厘清我是怎样设立投资支点，验证投资支点，并最后止盈退出的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">当然，在具体的投资行为中，还有调研、选股、择时等诸多会影响投资结果的细节问题。但只要你在每次主动投资时都遵循支点投资法，就一定能不断丰富自己的经验，提高自己发现投资支点的能力。在投资之路上，只有方向正确，我们的所有努力才是有意义的，这就是我一再强调投资支点重要性的原因。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>作者举了个自己使用支点投资法投资美国航空（AAL），获得了43.3%的收益的  例子。挺有说服力的。</p>
<p><em><strong>但是咋说呢，其实这个东西就是“博反弹”嘛，只适用于短期投资，纯属投机行为，对时机的把握要相当精准，出手要快、准、狠。我不喜欢玩短线，所以对我来说没啥用。</strong></em></p>
<p>相关内容可以参考 <em><strong><a href="https://xueqiu.com/4587623715/201709534" target="_blank" rel="noopener noreferrer">投资之术（二）----博反弹 在股市中，趋势的演变进程都是很复杂的，两点一线最简单、最直接，趋势也一目了然最清楚，但实际上这种情形很少出现，趋势的演变... - 雪球</a></strong></em></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 反弹是在下跌趋势中的小级别回升，博取的是反弹过程中的差价，此时并不能确认股价已经见底，只是在下跌过程中赚一点小回升的差价而已。因为具有一定的反弹获利空间，故具有一定的参与价值和可操作性。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对价值投资者来说，不存在博反弹一说，因为其买入标准是价格低于价值达到一定程度（具有安全边际）时，只是买入时机的选择有讲究，在下跌趋势未扭转前买入属于左侧买入，在下跌趋势止住开始震荡时是底部买入，在上升趋势形成后属于右侧买入。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在此先重点说明，博反弹是针对趋势投资者而言的，播反弹是一种高难度交易行为，对散户朋友来说，没有一定技巧，尽量不要去做这种交易行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">博反弹的难度在于赔率不够高，是短期行为，纯属投机行为，对时机的把握要相当精准，出手要快、准、狠，对性格要求果敢、坚决，不适合有拖延症、犹豫不决、不善控制自我情绪及他人判定型性格的人。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">正因为博反弹难度高，所以，在实践中一定要小心谨慎，选择标准一定要严格，宁缺毋滥，宁愿错过不要做错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/11%20%e8%b4%a2%e5%af%8c%e6%8b%93%e5%b1%95%ef%bc%9a35%e5%b2%81%e5%a4%b1%e4%b8%9a%ef%bc%9f%e7%a8%8b%e5%ba%8f%e5%91%98%e5%a6%82%e4%bd%95%e6%8b%93%e5%ae%bd%e8%b4%a2%e5%af%8c%e6%b8%a0%e9%81%93%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">11 财富拓展：35岁失业？程序员如何拓宽财富渠道？</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/15%20%e5%ae%9e%e6%88%98%e7%9f%a5%e8%af%86%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%89%e5%87%ba%e4%b8%80%e5%8f%aa%e4%bc%98%e8%b4%a8%e7%9a%84%e5%9f%ba%e9%87%91%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">15 实战知识：如何选出一只优质的基金？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">基金的建仓与再平衡</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">到这里，我们已经选好了实现耶鲁组合的基金，下面就该进入具体的交易操作了。这里，我有一些关于建仓的小知识分享给你。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于波动性比较小的债基，不同时点的建仓成本变化不大，所以没必要定投，直接一步到位就可以，分批定投反而会错失债券的时间收益。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">对于波动性比较大的股票  型基金，比如说国内的普通股票型基金和标普500的指数基金，是可以考虑在3个月到半年这样的时间尺度上分批建仓的，因为这样可以平滑掉你的建仓时点选择的风险。另外，如果你的可投现金流是按月收到的，那就没得选，只能是定投，每月收到一笔钱投一笔。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">建好仓后，下面的事情就是定期的资产配置再平衡了。作为普通投资者，只要我们在购买基金的时候进行了充足的分析，是没有必要在平时频繁查看这个配置组合的。我们只需要每隔一个季度，或者在市场出现大幅波动的时候，计算一下基金组合在几类资产上的配置比例是否因为价格的变化偏离过大。如果偏离不多，就可以不用管，如果偏离得比较大了，就把它再平衡一次，重新调回初始比例。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">调整大类资产配置比例的过程，当然要通过申购和赎回具体基金来完成。你可以按照之前选定的基金组合执行再平衡，卖掉资产占比增大的基金，买入资产占比减小的基金；你也可以借着调整顶层配置比例的机会，卖掉一些你不太看好的基金，换成一些你比较看好的基金。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>看这段的时候，总感觉好像之前看过，大概是20年前后？那波牛市的时候</p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/17%20%e6%8a%95%e8%b5%84%e9%97%ad%e7%8e%af%ef%bc%9a%e5%a6%82%e4%bd%95%e6%88%90%e4%b8%ba%e8%b6%8a%e6%9d%a5%e8%b6%8a%e4%b8%93%e4%b8%9a%e7%9a%84%e6%8a%95%e8%b5%84%e8%80%85%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">17 投资闭环：如何成为越来越专业的投资者？</a> 分别介绍了作者自己对两次投资经历的复盘，最空纳指认输离场和买蔚来股票浮盈110%成功止盈，一正一反来介绍复盘的重要性。之后又介绍了怎么建立投资跟踪表。</p>
<p><img decoding="async" loading="lazy" alt="wealth-investment-tracking-sheet.jpg" src="/zh-Hans/assets/images/wealth-investment-tracking-sheet-c6fb1376fbae2acab3349dac19a6833b.jpg" width="2248" height="756" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">第一个阶段是“头脑风暴阶段”，主要负责记录你发现的任何可能的投资机会。这些机会可能是你自己在观察熟悉的投资标的时发现的，可能是你在跟同事朋友讨论时得出的，也可能是你看了一篇文章，或者听了某位专家介绍，觉得有道理而记下的。总之，只要你有新的投资想法，都要新开一条记录，不用管这  个想法靠不靠谱，因为这个阶段的目的就是为你积累大量的支点素材。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第二个阶段是“支点研究阶段”。这个阶段的目的是把你非常粗糙的支点素材打磨成一个可行的投资行为。它就像一个漏斗，把不靠谱的，或者你认为优先级不高的支点素材过滤掉。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在图5中，我针对“银行地产行业被低估”这一支点素材，进行了一些投资分析，查阅了房地产行业的PE、历史估值分位数、基本面等数据，最终确认可以开始对应的投资行为。当然，如果通过研究，你发现自己的支点站不住脚，就应该把这个支点停止在研究阶段，不要进一步触发实质的投资行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">第三个阶段就是实际执行的“投资跟踪阶段”，我们应该根据支点投资法，详细记录投资行为触发和退出的时间，以及触发退出的逻辑。并且，在一切都尘埃落定之后，复盘整个投资过程，把复盘的关键点记录下来，供之后进行投资时参考。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/18%20%e6%8a%80%e6%9c%af%e4%bc%98%e5%8a%bf%ef%bc%9a%e7%a8%8b%e5%ba%8f%e5%91%98%e5%a6%82%e4%bd%95%e7%94%a8%e6%8a%80%e6%9c%af%e8%b6%85%e8%b6%8a%e5%85%b6%e4%bb%96%e6%8a%95%e8%b5%84%e8%80%85%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">18 技术优势：程序员如何用技术超越其他投资者？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">到这里，我用三个例子，解释了程序员的技术优势到底体现在哪些方向。这里，我再总结一下这一讲的重点内容，也就是这三个例子中体现的关键思想：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1、程序员的技术优势是我们强于其他投资者的地方，一定要懂得利用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2、高效获取信息是实现技术优势的第一个方向。典型的例子是利用程序，高效获取投资决策所需的信息，帮助我们做出最全面和理性的决策。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3、投资支点的验证是第二个方向。典型的例子是利用程序去回测我们的投资想法，在实盘交易前做充分的验证。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4、实现技术优势的第三个方向是“固化规则，解放人力”。典型的例子是程序化交易，它可以最大程度地解放我们的人力，相当于雇佣了一个认真负责的交易员给你打工。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1、对于日历效应策略，我们能不能设计一个实验，去验证市场的资金到底是不是在月末吃紧，月初流动性增强呢？可以在留言区说说你的设计思路。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2、在程序化交易那个小节，我提到了期货交易接口CTP，你可以去搜索下它的相关资料，在留言区跟大家分享。比如，CTP的全称是什么？它是由哪个机构管理的？</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/19%20%e9%87%8f%e5%8c%96%e6%8a%95%e8%b5%84%ef%bc%9a%e5%85%b8%e5%9e%8b%e7%9a%84%e9%87%8f%e5%8c%96%e6%8a%95%e8%b5%84%e7%b3%bb%e7%bb%9f%e9%83%bd%e5%8c%85%e5%90%ab%e5%93%aa%e4%ba%9b%e6%a8%a1%e5%9d%97%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">19 量化投资：典型的量化投资系统都包含哪些模块？</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/20%20%e4%bb%b7%e5%80%bc%e6%8a%95%e8%b5%84%ef%bc%9a%e6%b0%b8%e8%bf%9c%e4%b8%8d%e8%bf%87%e6%97%b6%e7%9a%84%e4%b8%ad%e9%95%bf%e6%9c%9f%e6%8a%95%e8%b5%84%e7%ad%96%e7%95%a5.md" target="_blank" rel="noopener noreferrer">20 价值投资：永远不过时的中长期投资策略</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/23%20%e5%af%b9%e5%86%b2%e6%80%9d%e6%83%b3%ef%bc%9a%e8%bf%99%e4%b8%aa%e4%b8%96%e7%95%8c%e4%b8%8a%e6%9c%89%e7%a8%b3%e8%b5%9a%e4%b8%8d%e8%b5%94%e7%9a%84%e7%94%9f%e6%84%8f%e5%90%97%ef%bc%9f.md" target="_blank" rel="noopener noreferrer">23 对冲思想：这个世界上有稳赚不赔的生意吗？</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">这一讲，我们一起学习了对冲思想。对冲思想的最关键作用是把你不想要的风险规避掉，只精确暴露于跟你的收益最相关的风险敞口。最后，我们再一起回顾下今天的要点：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1、对冲思想，是一种通过同时持有一组对主要风险因素具有反向暴露的不同标的，来降低或消除投资组合整体风险的投资思想。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2、对冲思想诞生于1949年由阿尔弗雷德·琼斯管理的对冲基金。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3、经典的对冲策略包括配对交易、宏观对冲和市场中性策略等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4、在市场中性策略的例子中我们看到，进行对冲掉市场风险的操作后，可以把产品最大回撤降低到5%以下，让净值曲线从波动上升变成稳健上升。这证明对冲思想确实能改造投资策略的风险收益特征。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5、对冲思想的应用是非常广泛的，你可以灵活地运用对冲思想，来规避财富管理道路上的风险。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/24%20%e5%a4%9a%e5%9b%a0%e5%ad%90%e6%a8%a1%e5%9e%8b%ef%bc%9a%e6%95%b4%e5%90%88%e4%b8%8d%e5%90%8c%e7%ad%96%e7%95%a5%ef%bc%8c%e5%bd%a2%e6%88%90%e5%90%88%e5%8a%9b%e7%9a%84%e9%a1%b6%e5%b1%82%e6%a1%86%e6%9e%b6.md" target="_blank" rel="noopener noreferrer">24 多因子模型：整合不同策略，形成合力的顶层框架</a></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">这一讲中，我们学习了多因子模型，它是一种能够融合多因子、多策略的模型，是能形成合力，提高我们投资胜率的顶层框架。在这里，我再总结下今天的几个重点知识，供你回顾：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1、多因子模型建立在坚实的数学基础上，是把多个因子整合在一起，发挥出最大作用的投资模型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2、在股票投资中，我们考虑的因子主要包括宏观因子、行业因子、技术面因子、基本面因子和大数据因子等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3、线性多因子模型的数学形式：r = f1 </span><span class="token italic punctuation" style="color:#393A34">*</span><span class="token italic content"> X1 + f2 </span><span class="token italic punctuation" style="color:#393A34">*</span><span class="token plain"> X2 + … + fK * XK。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4、线性多因子模型的训练，主要是通过在股票面板样本上进行线性回归完成的。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5、在进行财富管理时，也可以运用多因子模型的思路：在做事情的时候分清主次，合理分配自己的时间和精力。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">你觉得线性多因子模型最大的局限性在哪里？你能结合自己做投资时的判断过程，来说明线性多因子模型的缺点吗？</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/26%20%e9%87%8f%e5%8c%96%e5%ae%9e%e6%88%98%ef%bc%9a%e4%bb%8e0%e5%88%b01%e6%90%ad%e5%bb%ba%e8%b5%b7%e4%b8%80%e5%a5%97%e7%ae%80%e5%8d%95%e7%9a%84%e9%87%8f%e5%8c%96%e6%8a%95%e8%b5%84%e7%b3%bb%e7%bb%9f%ef%bc%88%e4%b8%8a%ef%bc%89.md" target="_blank" rel="noopener noreferrer">26 量化实战：从0到1搭建起一套简单的量化投资系统（上）</a> 这个我打算自己实操一下</p>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e7%a8%8b%e5%ba%8f%e5%91%98%e7%9a%84%e4%b8%aa%e4%ba%ba%e8%b4%a2%e5%af%8c%e8%af%be/27%20%e9%87%8f%e5%8c%96%e5%ae%9e%e6%88%98%ef%bc%9a%e4%bb%8e0%e5%88%b01%e6%90%ad%e5%bb%ba%e8%b5%b7%e4%b8%80%e5%a5%97%e7%ae%80%e5%8d%95%e7%9a%84%e9%87%8f%e5%8c%96%e6%8a%95%e8%b5%84%e7%b3%bb%e7%bb%9f%ef%bc%88%e4%b8%8b%ef%bc%89.md" target="_blank" rel="noopener noreferrer">27 量化实战：从0到1搭建起一套简单的量化投资系统（下）</a></p>
<hr>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">因子投资：《因子投资：方法与实践》</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">在我看来，这是近年来最好的讲解多因子模型的专著，不仅思想深刻，表述也准确生动。这本书很适合那些想要深入研究多因子模型，并开发因子投资策略的同学。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token hr punctuation" style="color:#393A34">---</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">量化分析圣经：《主动投资组合管理》</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">这本书的两位作者是量化投资行业的先驱者，并且都曾经担任BARRA公司的研究总监。它的内容相对较深，描述也偏实践，介绍了许多深刻的真知，书中的很多论述精彩而透彻。这本书被奉为量化组合投资的业界“圣经”。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">不过，该书有些章节撰写得深度不一，初学者阅读起来可能会觉得吃力。所以我推荐的阅读方法是：首次阅读时，不必纠结看不懂的细节，只要不影响后续阅读就跳过；有一定基础后，再反复阅读本书，每次阅读都会获得新的体会。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">好了，以上就是我今天推荐的全部资料。财富管理是一生的事情，我们的课程只是你个人财富管理的起点。要想获得更有效的财富增长，你还需要持续学习，建立强大的认知优势。希望我们这门课帮助你明确了努力的方向，在前进的过程中，你一定会收获到更有价值的东西。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">如果你还想了解一些其他方面的投资学习资料，欢迎在评论区提出来，我们继续交流讨论。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><img decoding="async" loading="lazy" alt="wealth-mindmap-1.jpg" src="/zh-Hans/assets/images/wealth-mindmap-1-94c6cde89aa22d52b1e180c52248c37d.jpg" width="2248" height="1260" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="wealth-mindmap-2.jpg" src="/zh-Hans/assets/images/wealth-mindmap-2-05348378178e62ce16dd55d9cb0cd2e2.jpg" width="2248" height="1115" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="wealth-mindmap-3.jpg" src="/zh-Hans/assets/images/wealth-mindmap-3-c572a84619fc712fbb8663dc1f34dea0.jpg" width="2247" height="913" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="wealth-mindmap-4.jpg" src="/zh-Hans/assets/images/wealth-mindmap-4-7254bb81304b7906c6ebcd81a7506d07.jpg" width="2248" height="3915" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="wealth-mindmap-5.jpg" src="/zh-Hans/assets/images/wealth-mindmap-5-14371ba2451139e0e83c3918b17e0558.jpg" width="2248" height="7130" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="重学操作系统">《重学操作系统》<a href="#重学操作系统" class="hash-link" aria-label="《重学操作系统》的直接链接" title="《重学操作系统》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C" target="_blank" rel="noopener noreferrer">重学操作系统-完</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="白话法律42讲">《白话法律42讲》<a href="#白话法律42讲" class="hash-link" aria-label="《白话法律42讲》的直接链接" title="《白话法律42讲》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B42%E8%AE%B2" target="_blank" rel="noopener noreferrer">白话法律42讲</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="反爬虫兵法演绎20讲">《反爬虫兵法演绎20讲》<a href="#反爬虫兵法演绎20讲" class="hash-link" aria-label="《反爬虫兵法演绎20讲》的直接链接" title="《反爬虫兵法演绎20讲》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%8F%8D%E7%88%AC%E8%99%AB%E5%85%B5%E6%B3%95%E6%BC%94%E7%BB%8E20%E8%AE%B2" target="_blank" rel="noopener noreferrer">反爬虫兵法演绎20讲</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="代码之丑">《代码之丑》<a href="#代码之丑" class="hash-link" aria-label="《代码之丑》的直接链接" title="《代码之丑》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%A3%E7%A0%81%E4%B9%8B%E4%B8%91" target="_blank" rel="noopener noreferrer">代码之丑</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="互联网消费金融高并发领域设计">《互联网消费金融高并发领域设计》<a href="#互联网消费金融高并发领域设计" class="hash-link" aria-label="《互联网消费金融高并发领域设计》的直接链接" title="《互联网消费金融高并发领域设计》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BA%92%E8%81%94%E7%BD%91%E6%B6%88%E8%B4%B9%E9%87%91%E8%9E%8D%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener noreferrer">互联网消费金融高并发领域设计</a></p>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e4%ba%92%e8%81%94%e7%bd%91%e6%b6%88%e8%b4%b9%e9%87%91%e8%9e%8d%e9%ab%98%e5%b9%b6%e5%8f%91%e9%a2%86%e5%9f%9f%e8%ae%be%e8%ae%a1/04%20%e6%9e%84%e5%bb%ba%e9%ab%98%e5%b9%b6%e5%8f%91%e4%ba%92%e8%81%94%e7%bd%91%e6%b6%88%e8%b4%b9%e9%87%91%e8%9e%8d%e4%bd%93%e7%b3%bb%e7%9a%84%e9%a2%86%e5%9f%9f%e8%a7%84%e5%88%92%e8%ae%be%e8%ae%a1.md" target="_blank" rel="noopener noreferrer">04 构建高并发互联网消费金融体系的领域规 划设计</a></p>
<p><img decoding="async" loading="lazy" alt="itfin-merchants.png" src="/zh-Hans/assets/images/itfin-merchants-adc2a946b82d4bbc77c675e2650b7b29.png" width="679" height="418" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">小额现金贷</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	直接向借款人提供资金；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	金额较小，一般五万以内；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	全流程线上化，实时审批放款；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">常规信用贷</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	直接向借款人提供资金；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	金额3-30万；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	全流程线上化，但实际审批会有电话征信等环节，通常1-24小时内放款；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">场景消费贷</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	资金向服务、产品提供方划转；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	金额根据场景确定，通常不超过10万；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	全流程线 上化，实时放款。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>互联网消费信贷常见模式有：小额现金贷、常规信用贷、场景消费贷三大类</p>
<p>但是大部分</p>
<p><img decoding="async" loading="lazy" alt="itfin-feats.png" src="/zh-Hans/assets/images/itfin-feats-523b5cb6a348a01ad83f3e90d5a3fa68.png" width="738" height="418" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1、在依托场景方面，常常与各类商品、服务提供商进行合作，在大数据征信层面，也常常会有征信公司进行全程参与。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2、在资金端方面，有些以自有资金或银行金融机构的资金进行放贷，还有些通过理财平台进行融资后再进行放贷。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3、在支付方式方面，也常常与第三方支付平台进行合作，通过其来进行放贷或资金回款，极大的提高了资金的流动效率；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4、在具体支付对象方面，有的是直接将款项直接支付给消费者，有的是直接支付给产品、服务提供商。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><img decoding="async" loading="lazy" alt="itfin-evolution.png" src="/zh-Hans/assets/images/itfin-evolution-ae3d281afe45787d6104ae6ab8154ee1.png" width="1003" height="480" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="itfin-arch.png" src="/zh-Hans/assets/images/itfin-arch-2a4ee34df5a814463b234c98e1237c36.png" width="820" height="514" class="img_ev3q"></p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">风控规则模型介绍</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">风控模型应该是从两个角度去考虑，第一个角度是资产端风控策略，第二个角度是资金端风控策略。考虑主要出发点应该是从贷前、袋中、贷后三个方向去考虑，结合传统业务的风控模型和互联用户的行为数据。针对资金，资产进行风险等级划分，防欺诈系统、袋中的舆情监控、贷后的权重叠加。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1）. 准入规则：对不同客户制定不同的贷款门槛，比如根据注册年限和消费次数等设置一个基本的准入门槛，对于后期可以分层次分批次的制定不同的风控策略。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2）. 反欺诈模型：从申请反欺诈、行为反欺诈、设备反欺诈等多维度制定反欺诈规则，确保及时侦测和处置可疑警告，维护黑名单数据库及时性、准确性、有效性，熟悉了解贷前、贷中、贷后业务全流程对反欺诈功能的需求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	白名单: 可以通过建立数据模型已经数据挖掘，机器学习相关算法进行优质用户的挖掘。</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	黑名单: 黑名单企业可以  针对那些逾期、破产企业(法人作为黑名单)、通过手机号码、imei作为用户判断标识，调用第三放征信公司去进行鉴别。</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3）. 评分卡：根据风险策略设置相应的权重，指定出完整的评分模型，并依据评分结果指定出审批策略、授信策略等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4）. 风险等级划分：将不同的客群进行细分，采用决策树或规则组的方式对不同的客群制定不同的策略和规则，实行精细化审批。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5）. 贷后检测：对信贷客户进行日常贷后监测，及时发现风险信号，对于触发风险预警的客户采取一定的措施，如电话核实、提前收回贷款等。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6）. 模型优化与验证：跟踪、监测、维护及优化风控策略，确保风控策略的效能及其提升。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<hr>
<p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e4%ba%92%e8%81%94%e7%bd%91%e6%b6%88%e8%b4%b9%e9%87%91%e8%9e%8d%e9%ab%98%e5%b9%b6%e5%8f%91%e9%a2%86%e5%9f%9f%e8%ae%be%e8%ae%a1/05%20%e4%ba%92%e8%81%94%e7%bd%91%e6%b6%88%e8%b4%b9%e9%87%91%e8%9e%8d%e9%ab%98%e5%b9%b6%e5%8f%91%e5%9c%ba%e6%99%af%e4%b8%8b%e7%9b%91%e6%8e%a7%e4%bd%93%e7%b3%bb%e5%bb%ba%e8%ae%be.md" target="_blank" rel="noopener noreferrer">05 互联网消费金融高并发场景下监控体系建设</a></p>
<p>互联网消费金融主要业务场景监控</p>
<div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">业务汇总类监控</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	1） 对当天的进件量进行监控。</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：当天进件量超过50000件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	2） 进件审批场景的监控：如审批的数量、失败数进行监控；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：当天审批失败的笔数及客户数超过30笔；当天累计审批通过1000笔。</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	3） 实时客户访问数量进行监控；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：当前客户访问量超过10000；当前客户访问量比上周同比增加80%；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	4） 对累计放款金额的监控：</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：当天累计放款金额超过一千万；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">贷款流程监控</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	1） 放款、还款流程监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：信用小贷产品未放款或放款失败，订单号：xxx1000；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	2） 审批环节监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：信用小贷产品自动审批出错，错误码：10010；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	3） 风控环节监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：风控规则组出错，错误码：10010；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	4） 关键业务规则监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：出现贷款额度大于1千万的合同；出现贷款利率超过30%的借据；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">定时跑批监控</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	1） 跑批节点进行监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：日终批量补充批节点出错，错误码：10010；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	2） 跑批时效进行监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：日终批量补充批节处理时间超过1小时；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">外部接口监控</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	1） 调用外部接口超时监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：人行征信接口连续20秒内相应时间大于10秒；</span><br></span><span class="token-line" style="color:#393A34"><span class="token code keyword" style="color:#00009f">	2） 调用外部接口出错监控</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token code keyword" style="color:#00009f">	例子：公积金查询接口连续出错10次；</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="web漏洞挖掘实战">《Web漏洞挖掘实战》<a href="#web漏洞挖掘实战" class="hash-link" aria-label="《Web漏洞挖掘实战》的直接链接" title="《Web漏洞挖掘实战》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98" target="_blank" rel="noopener noreferrer">Web漏洞挖掘实战</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="webassembly入门课">《WebAssembly入门课》<a href="#webassembly入门课" class="hash-link" aria-label="《WebAssembly入门课》的直接链接" title="《WebAssembly入门课》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/WebAssembly%E5%85%A5%E9%97%A8%E8%AF%BE" target="_blank" rel="noopener noreferrer">WebAssembly入门课</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="rocketmq-实战与进阶">《RocketMQ 实战与进阶》<a href="#rocketmq-实战与进阶" class="hash-link" aria-label="《RocketMQ 实战与进阶》的直接链接" title="《RocketMQ 实战与进阶》的直接链接">​</a></h2>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/RocketMQ%20%E5%AE%9E%E6%88%98%E4%B8%8E%E8%BF%9B%E9%98%B6%EF%BC%88%E5%AE%8C%EF%BC%89" target="_blank" rel="noopener noreferrer">RocketMQ 实战与进阶（完）</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bytebytegohqsystem-design-101">ByteByteGoHq/system-design-101<a href="#bytebytegohqsystem-design-101" class="hash-link" aria-label="ByteByteGoHq/system-design-101的直接链接" title="ByteByteGoHq/system-design-101的直接链接">​</a></h2>
<p><a href="https://github.com/ByteByteGoHq/system-design-101" target="_blank" rel="noopener noreferrer">ByteByteGoHq/system-design-101: Explain complex systems using visuals and simple terms. Help you prepare for system design interviews.</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bayern01kahntech_diagrams">bayern01kahn/Tech_Diagrams<a href="#bayern01kahntech_diagrams" class="hash-link" aria-label="bayern01kahn/Tech_Diagrams的直接链接" title="bayern01kahn/Tech_Diagrams的直接链接">​</a></h2>
<p><a href="https://github.com/bayern01kahn/Tech_Diagrams" target="_blank" rel="noopener noreferrer">bayern01kahn/Tech_Diagrams: <!-- -->🏁<!-- -->​ 全端技术-核心知识点-底层原理(源码) 归纳总结图(drawio) Fullstack-core tech-summary based of drawio</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bregman-ariedevops-exercises">bregman-arie/devops-exercises<a href="#bregman-ariedevops-exercises" class="hash-link" aria-label="bregman-arie/devops-exercises的直接链接" title="bregman-arie/devops-exercises的直接链接">​</a></h2>
<div class="language-yaml codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-yaml codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">url</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> https</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//github.com/bregman</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">arie/devops</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">exercises</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">des</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 非常好用的，可以用来作为devops面试题，也可以平时随便看看</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"></div><div class="col lastUpdated_JAkA"><span class="theme-last-updated">最后<!-- -->由 <b>XBPk3T</b> <!-- -->于 <b><time datetime="2024-10-07T00:00:00.000Z" itemprop="dateModified">2024年10月7日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/zh-Hans/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Archive</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/zh-Hans/2024/reading-methods"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">《聪明的阅读者》读书笔记</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#go-语言项目开发实战读书笔记" class="table-of-contents__link toc-highlight">《Go 语言项目开发实战》读书笔记</a><ul><li><a href="#git-commit" class="table-of-contents__link toc-highlight">git commit</a></li><li><a href="#makefile" class="table-of-contents__link toc-highlight">Makefile</a></li><li><a href="#golang-spec" class="table-of-contents__link toc-highlight">golang spec</a></li><li><a href="#用cronredsync自己实现分布式任务调度系统" class="table-of-contents__link toc-highlight">用cron+redsync自己实现分布式任务调度系统</a></li></ul></li><li><a href="#许式伟的架构课读书笔记" class="table-of-contents__link toc-highlight">《许式伟的架构课》读书笔记</a><ul><li><a href="#服务开发篇-34-46" class="table-of-contents__link toc-highlight">服务开发篇 (34-46)</a></li><li><a href="#服务治理篇-47-56" class="table-of-contents__link toc-highlight">服务治理篇 (47-56)</a></li><li><a href="#架构思维篇-57-67" class="table-of-contents__link toc-highlight">架构思维篇 (57-67)</a></li><li><a href="#软件工程篇-68-77" class="table-of-contents__link toc-highlight">软件工程篇 (68-77)</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></li><li><a href="#架构设计面试精讲" class="table-of-contents__link toc-highlight">《架构设计面试精讲》</a><ul><li><a href="#分布式系统-3-8" class="table-of-contents__link toc-highlight">分布式系统 (3-8)</a></li><li><a href="#系统设计-15-19" class="table-of-contents__link toc-highlight">系统设计 (15-19)</a></li><li><a href="#总结-1" class="table-of-contents__link toc-highlight">总结</a></li></ul></li><li><a href="#从-0-开始学架构" class="table-of-contents__link toc-highlight"><del>《从 0 开始学架构》</del></a></li><li><a href="#周志明的架构课" class="table-of-contents__link toc-highlight"><del>《周志明的架构课》</del></a></li><li><a href="#高并发系统设计40问" class="table-of-contents__link toc-highlight"><del>《高并发系统设计40问》</del></a></li><li><a href="#由浅入深吃透-docker" class="table-of-contents__link toc-highlight"><del>《由浅入深吃透 Docker》</del></a></li><li><a href="#深入浅出-docker-技术栈实践课" class="table-of-contents__link toc-highlight"><del>《深入浅出 Docker 技术栈实践课》</del></a></li><li><a href="#容器实战高手课" class="table-of-contents__link toc-highlight"><del><em><strong>《容器实战高手课》</strong></em></del></a></li><li><a href="#csapp以及深入浅出计算机组成原理" class="table-of-contents__link toc-highlight">《csapp》以及《深入浅出计算机组成原理》</a></li><li><a href="#分布式中间件实践之路" class="table-of-contents__link toc-highlight"><del>《分布式中间件实践之路》</del></a></li><li><a href="#分布式技术原理与实战45讲" class="table-of-contents__link toc-highlight"><em><strong>《分布式技术原理与实战45讲》</strong></em></a></li><li><a href="#24讲吃透分布式数据库" class="table-of-contents__link toc-highlight">《24讲吃透分布式数据库》</a></li><li><a href="#300分钟吃透分布式缓存" class="table-of-contents__link toc-highlight">《300分钟吃透分布式缓存》</a></li><li><a href="#elasticsearch知识体系详解" class="table-of-contents__link toc-highlight">《ElasticSearch知识体系详解》</a></li><li><a href="#etcd实战课" class="table-of-contents__link toc-highlight">《etcd实战课》</a></li><li><a href="#后端技术面试38讲" class="table-of-contents__link toc-highlight">《后端技术面试38讲》</a></li><li><a href="#深入理解-sentinel" class="table-of-contents__link toc-highlight">《深入理解 Sentinel》</a></li><li><a href="#程序员的个人财富课" class="table-of-contents__link toc-highlight">《程序员的个人财富课》</a></li><li><a href="#重学操作系统" class="table-of-contents__link toc-highlight">《重学操作系统》</a></li><li><a href="#白话法律42讲" class="table-of-contents__link toc-highlight">《白话法律42讲》</a></li><li><a href="#反爬虫兵法演绎20讲" class="table-of-contents__link toc-highlight">《反爬虫兵法演绎20讲》</a></li><li><a href="#代码之丑" class="table-of-contents__link toc-highlight">《代码之丑》</a></li><li><a href="#互联网消费金融高并发领域设计" class="table-of-contents__link toc-highlight">《互联网消费金融高并发领域设计》</a></li><li><a href="#web漏洞挖掘实战" class="table-of-contents__link toc-highlight">《Web漏洞挖掘实战》</a></li><li><a href="#webassembly 入门课" class="table-of-contents__link toc-highlight">《WebAssembly入门课》</a></li><li><a href="#rocketmq-实战与进阶" class="table-of-contents__link toc-highlight">《RocketMQ 实战与进阶》</a></li><li><a href="#bytebytegohqsystem-design-101" class="table-of-contents__link toc-highlight">ByteByteGoHq/system-design-101</a></li><li><a href="#bayern01kahntech_diagrams" class="table-of-contents__link toc-highlight">bayern01kahn/Tech_Diagrams</a></li><li><a href="#bregman-ariedevops-exercises" class="table-of-contents__link toc-highlight">bregman-arie/devops-exercises</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Docs. Built with Docusaurus. Hosted by Github & Cloudflare.</div></div></div></footer></div>
</body>
</html>