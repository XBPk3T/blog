

```yaml
  qs:
    - q: "***Compare XA (2PC, 3PC), AT, TCC, SAGA, 基于异步消息(基于数据库, 基于消息中间件)  (一致性、隔离性、代码侵入性、性能、使用场景)***"
      u: https://www.bilibili.com/video/BV1K841167dR/
      x: |
        总结一下，XA和AT都是non-invasive的（而TCC和SAGA都是invasive的，通常不考虑）。AT和XA则正好互补，XA强一致性但是性能一般，AT则性能更好但是弱一致性。

         - TCC (Try-Confirm/Cancel): 最终一致的分阶段事务模式，有业务侵入，适用于一致性要求较高的短事务
         - SAGA: 长事务模式，有业务侵入，一致性要求较低的长事务
         - XA (eXtended Arch): 强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入，适用于并发要求不高的场景
         - 事务消息：不需要回滚的事务
         - AT (Application-Level Transaction): 最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式

        几种分布式事务方案的对比？

        - `一致性保证`XA>TCC=SAGA>事务消息
        - `业务友好性`XA>事务消息>SAGA>TCC
        - `性能损耗`XA>TCC>SAGA=事务消息

        ---

        - TCC: 适用于一致性要求较高的短事务
        - SAGA: 一致性要求较低的长事务
        - XA: 并发要求不高的事务
        - 事务消息：不需要回滚的事务

        ---

        我先说下我的理解，说的不一定对，然后再说下我们实际工作中是怎么解决的。解决DT就是协调事务和最终一致性两种，协调事务的方案有2PC、3PC和XA，最终一致性方案有TCC、本地消息表和SAGA。这几种方案都各有缺点，比如协调事务不管是2PC还是3PC，都必须引入协调者，那协调者本身就需要保证HA，如果是HA的，那他的一致性问题也需要考虑。协调事务最大的问题就是协调不一致的问题，比如一个commit或者rollback成功了，另一个commit或者rollback失败了。所以不管是2PC还是3PC都是降低这些情况发生的概率，不能完全避免。2PC和3PC都存在一定程度的阻塞，也就是说，性能相对会差点。最终一致性方案最大的优点就是无阻塞，能够提供良好的性能，适合高并发场景，但是其问题在于无法保证一致性，比如本地消息表方案可能会存在写入失败的问题，TCC需要先预留资源，还有涉及幂等的问题，所以DT绝对是遵循CAP理论的，当分区条件满足时，一致性和可用性肯定是无法同时满足的。

        我们以前做的业务是用会员积分兑换商品的场景，会员积分和订单分别是两个服务，用DTM作为DT框架，我们积分兑换商品的业务场景相对简单，所以使用AT模式来实现，AT模式是基于数据源代理对sql进行解析，把操作前后的数据记录到undolog表，也就是说参与tx的ab双方会分别注册tx协调器，a开启本地tx拿到本地锁，tx提交之前拿到全局锁释放本地锁，a的tx准备好之后b拿到本地锁，开始本地tx操作，b操作完之后释放本地锁，开始抢全局锁，此时ab都处于prepare状态，tx协调器会向双方发起commit命令，a执行commit之后释放全局锁，b获取全局锁执行commit，如果此时a commit失败，b获取不到全局锁直接rollback，如果a commit成功，b commit失败呢，则全局tx失败，tx协调器向a发起rollback命令，a会根据全局tx的id在本地表里查询回滚的数据，进行回滚，由此保证数据的强一致性。

        我们还有一个场景是注册送积分的，由于这个场景对一致性要求不高，所以我们会用MQ下发msg，在本地做个本地消息表，。但是后来发现基本上没有赠送积分出错的情况，所以我们采用了把这里的DT取消了（无事务的思想），直接走rdb，出错之后人工介入手动发放积分即可。



    - q: TCC是啥? 有啥特点? 执行流程?
      x: |
        相比于XA

        - 位于业务服务层而非资源层，由业务层保证原子性
        - 没有单独的准备 (Prepare) 阶段，降低了提交协议的成本


    - q: XA的2PC和3PC有啥区别?
      x: |
        狭义上的XA实际上就是2PC（因为3PC很难实现），3PC相比2PC就是多了一个PreCommit和“超时回滚机制”。但是还是上面说的，3PC很难实现，所以如果我们使用2PC，就需要面对其缺点，也就是单点故障、阻塞问题、数据不一致问题。拿朋友AA制聚餐举例，餐厅服务员就是协调者，而朋友就是参与者，那么两个阶段就是“投票”和“决定是否完成”，那么3PC就是多了一个服务员向每个参与者询问支付状态（也就是PreCommit），然后决定继续收钱还是取消支付。所以我妈说“3PC是对有人逃单的兜底”

        *2PC 就是吃饭 AA 制，3PC 则是对 AA 制有人逃单的兜底*
    - q: 2PC 为什么不好做水平拓展？
    - q: 为啥应该用XA而不是AT?
      u: https://dtm.pub/practice/at.html

    - q: 分布式事务中的异常处理有哪些关键点？
      x: |
        分布式事务中的异常处理需要关注空回滚、幂等和悬挂等问题。空回滚是指在没有执行Try操作的情况下执行Cancel操作。幂等是指分布式事务的每个分支都需要保证即使出现重复请求，也能正确处理。悬挂是指Cancel操作在Try操作之前执行的情况。为了处理这些异常，业务方需要通过唯一键查询操作是否已完成，或者实现相应的幂等控制和防悬挂逻辑。



```



