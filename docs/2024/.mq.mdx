


```yaml
  qs:
    - q: "***Compare kafka, NATS and NSQ?***"
      u: https://mp.weixin.qq.com/s?__biz=MzkyMzcxODg0MQ==&mid=2247522161&idx=1&sn=6689f4e75ba7fc00e283dae872592f97
      x: |
        arch, perf(throughput, latency), scalability, durability(fault tolerance, failover), msg delivery semantics, msg ordering, network model, storage model, feats(retry, delay queue) and use cases
        - 开发语言
        - 支持协议
        - 消息存储
        - 消息事务
        - 负载均衡
        - 集群方式
        - 管理界面
        - 可用性
        - 消息重复
        - 吞吐量 TPS
        - 订阅方式和消息分发
        - 顺序消息
        - 消息回溯
        - 消息重试
        - 并发度

    - q: "MQ能够解决哪些问题？***有哪些核心需求（或者说特点）？***"
      x: 通常认为MQ的作用是“削峰填谷、消息分发、异步通信、架构解耦”，按照我的理解，最核心的是“解耦和异步处理”，用来在高并发场景下平滑短时间内大量的服务请求，不使用消息队列的系统，根据木桶效应，性能取决于系统中性能最慢的组件，但是消息队列可以将组件解耦，各组件异步执行。如果没有 MQ，只能在服务里耦合限流服务，那么不管是上游限流，还是下游限流，都会引入业务的复杂性。所以，我们可以把限流通过 MQ 解决，也起到了解耦的作用。

    - q: MQ有哪些相关基础概念（比如说调度算法、消息模式）？
      x: |
        - `Broker`消息服务器，作为 server 提供消息核心服务
        - `Producer`消息发布者，业务的发起方，负责生产消息传输给 broker，
        - `Consumer`消息订阅者，业务的处理方，负责从 broker 获取消息并进行业务逻辑处理
        - `Topic`主题，发布订阅模式下的消息统一汇集地，不同发布者发布不同的主题，由消息服务器分发到不同的订阅者，实现消息的广播
        - `Queue`队列，某个发布者向指定 queue 发送消息，订阅者订阅特定的 queue 完成消息的点对点接收
        - `Message`消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输

    - q: 消息队列的消息模式是啥意思？kafka、NATS、NSQ这些都有什么消息模式？
      x: |
        四种

        - P2P
        - Pub/Sub
        - Request-Reply
        - Broadcast.

        本质来说被多少consumer接收和消费（比如说P2P就是只有1个consumer，而Pub/Sub和Broadcast则都有n个consumer接收，但是二者的区别是Broadcast只能被1个consumer消费掉。之于Request-Reply则不限制consumer数量）。

        最常用的就是点到点模型和推拉模型

        - 点对点模式
        - pub/sub模式（推拉模型）
            - 推模式：生产者将消息发送给消息队列，消息队列把消息推给消费者
            - 拉模式：消费者请求消息队列，接收消息。生产者从消息队列中拉取消息


    - q: "***MQ有哪些常见的坑？通常怎么解决?***"
      x: (顺序问题、背压（消息积压/队列阻塞）、主键冲突、数据库主从延迟、重复消费、丢消息) (duplicate msg, slow consumers)
    - q: 多线程并发读写是否一定要加锁？
    - q: 如何保证消息不被重复消费？
    - q: 消息队列丢消息了，怎么解决？如何保证消息的可靠传输？
    - q: 如何保证消息的顺序？
    - q: "*如果队列阻塞了，怎么办？（队列中有大量队列，怎么处理？）*"
      x: |
        - 监控队列，动态调用消费者，适时增加消费者
        - 做好降级方案，达到预设阈值，出队后暂不处理，直接先持久化再说
        - 消费者投递异步任务，不要阻塞出队列
    - q: "***有哪些实现延时队列的方法？优缺点？根据延时队列的核心需求，这些方案有哪些优缺点？***"
      x: |
        比如说，订单超时未支付自动关闭

        redis 的 zset+lua，设置 score 为过期的时间，通过 score 把 member 进行排序。消费端轮询这个 zset 队列，对比 score 和当前时间，进行消费。使用 eval 通过 lua 脚本实现 redis 的原子性操作（laravel 内置的延时队列就是这么实现的）

    - q: 常见的 MQ 中间件协议？Compare (AMPQ, MQTT, STOMP, XMPP, DDS, CoAP)?
      x: |
        Transport(lw? perf? reliable?), use cases(low-bandwidth? IoT? real-time? advanced feats?)

        - `AMPQ 协议`，高级消息队列协议，*AMPQ 不是一个具体的消息队列实现，而是一个标准化的消息中间件协议*。目标是让不同语言，不同系统的应用互相通信，并提供一个简单统一的模型和编程接口
        - `MQTT 协议`
        - `STOMP 协议`
        - `XMPP 协议`

```