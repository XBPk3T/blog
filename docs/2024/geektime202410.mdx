---
title: 速读几本极客时间课程
slug: /2024/golang-project-dev-practice
last_update:
  date: 2024-10-07
---




## 《Go 语言项目开发实战》读书笔记


[marmotedu/geekbang-go: 极客时间 《Go 语言项目开发实战》课程补充教程。](https://github.com/marmotedu/geekbang-go)




### git commit

[05 规范设计（下）：commit 信息风格迥异、难以阅读，如何规范？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/05%20%E8%A7%84%E8%8C%83%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9Acommit%20%E4%BF%A1%E6%81%AF%E9%A3%8E%E6%A0%BC%E8%BF%A5%E5%BC%82%E3%80%81%E9%9A%BE%E4%BB%A5%E9%98%85%E8%AF%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%EF%BC%9F.md)

---


![git-types-belongs.jpg](img/geektime202410/git-types-belongs.jpg)

![git-commit-types.jpg](img/geektime202410/git-commit-types.jpg)

```markdown
如果我们变更了应用代码，比如某个 Go 函数代码，那这次修改属于代码类。在代码类中，有 4 种具有明确变更意图的类型：feat、fix、perf 和 style；如果我们的代码变更不属于这 4 类，那就全都归为 refactor 类，也就是优化代码。

如果我们变更了非应用代码，例如更改了文档，那它属于非代码类。在非代码类中，有 3 种具有明确变更意图的类型：test、ci、docs；如果我们的非代码变更不属于这 3 类，那就全部归入到 chore 类。

Angular 的 Commit Message 规范提供了大部分的 type，在实际开发中，我们可以使用部分 type，或者扩展添加我们自己的 type。但无论选择哪种方式，我们一定要保证一个项目中的 type 类型一致。
```





---



```markdown
提交频率
在实际项目开发中，如果是个人项目，随意 commit 可能影响不大，但如果是多人开发的项目，随意 commit 不仅会让 Commit Message 变得难以理解，还会让其他研发同事觉得你不专业。因此，我们要规定 commit 的提交频率。

那到底什么时候进行 commit 最好呢？

我认为主要可以分成两种情况。一种情况是，只要我对项目进行了修改，一通过测试就立即 commit。比如修复完一个 bug、开发完一个小功能，或者开发完一个完整的功能，测试通过后就提交。另一种情况是，我们规定一个时间，定期提交。这里我建议代码下班前固定提交一次，并且要确保本地未提交的代码，延期不超过 1 天。这样，如果本地代码丢失，可以尽可能减少丢失的代码量。

按照上面 2 种方式提交代码，你可能会觉得代码 commit 比较多，看起来比较随意。或者说，我们想等开发完一个完整的功能之后，放在一个 commit 中一起提交。这时候，我们可以在最后合并代码或者提交 Pull Request 前，执行 git rebase -i 合并之前的所有 commit。

那么如何合并 commit 呢？接下来，我来详细说说。
```




```markdown
修改 Commit Message

```




:::danger

- 提交频率
- 合并提交
- 修改 commit message

:::






### Makefile

[14 项目管理：如何编写高质量的Makefile？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/14%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84Makefile%EF%BC%9F.md)

```markdown
首先，你需要熟练掌握Makefile的语法。我建议你重点掌握以下语法：Makefile规则语法、伪目标、变量赋值、特殊变量、自动化变量、条件语句和Makefile常用函数。

接着，我们需要提前规划Makefile要实现的功能。一个大型Go项目通常需要实现以下功能：代码生成类命令、格式化类命令、静态代码检查、 测试类命令、构建类命令、Docker镜像打包类命令、部署类命令、清理类命令，等等。

然后，我们还需要通过Makefile功能分类、文件分层、复杂命令脚本化等方式，来设计一个合理的Makefile结构。

最后，我们还需要掌握一些Makefile编写技巧，例如：善用通配符、自动变量和函数；编写可扩展的Makefile；使用带层级的命名方式，等等。通过这些技巧，可以进一步保证我们编写出一个高质量的Makefile。
```


- makefile语法
- makefile编写技巧




```makefile
include scripts/make-rules/golang.mk
include scripts/make-rules/image.mk
include scripts/make-rules/gen.mk
include scripts/make-rules/...

## build: Build source code for host platform.
.PHONY: build
build:
	@$(MAKE) go.build

## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.
.PHONY: build.multiarch
build.multiarch:
	@$(MAKE) go.build.multiarch

## image: Build docker images for host arch.
.PHONY: image
image:
	@$(MAKE) image.build

## push: Build docker images for host arch and push images to registry.
.PHONY: push
push:
	@$(MAKE) image.push

## ca: Generate CA files for all iam components.
.PHONY: ca
ca:
	@$(MAKE) gen.ca
```


```markdown
另外，一个合理的Makefile结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好Makefile当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用Makefile编程技巧，编写可扩展的Makefile。

这里需要你注意：上面的Makefile通过 .PHONY 标识定义了大量的伪目标，定义伪目标一定要加 .PHONY 标识，否则当有同名的文件时，伪目标可能不会被执行。
```


[seisman/how-to-write-makefile: 跟我一起写Makefile重制版](https://github.com/seisman/how-to-write-makefile)

[跟我一起写Makefile — 跟我一起写Makefile 1.0 文档](https://seisman.github.io/how-to-write-makefile/)


[特别放送 给你一份Go项目中最常用的Makefile核心语法](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BB%BDGo%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84Makefile%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95.md)



### golang spec

:::tip

[code-spec.md](code-spec.md)

:::

[特别放送 给你一份清晰、可直接套用的Go编码规范](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E7%BB%99%E4%BD%A0%E4%B8%80%E4%BB%BD%E6%B8%85%E6%99%B0%E3%80%81%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A5%97%E7%94%A8%E7%9A%84Go%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.md)








### 用cron+redsync自己实现分布式任务调度系统


[特别放送 分布式作业系统设计和实现](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Go%20%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/%E7%89%B9%E5%88%AB%E6%94%BE%E9%80%81%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BD%9C%E4%B8%9A%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0.md)





## 《许式伟的架构课》读书笔记

[许式伟的架构课](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E8%AE%B8%E5%BC%8F%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE) 可以看到这本书分为几部分，从6到19是kernel相关，都有点基础了，不看；20到33是桌面client相关，用不到不看；34到46是“服务开发篇”；47到56是“服务治理篇”；57到67是“架构思维篇”；68到77是“软件工程篇”。

---



[许式伟的架构课Day8如何阅读别人的代码为什么要阅读别人的代码 阅读别人代码的目的性: 我要评估是否引入第三方模块 我要 - 掘金](https://juejin.cn/post/7208188047707340855)

[《许式伟的架构课》笔记 | 李乾坤的博客](https://qiankunli.github.io/2020/11/24/architecture_note.html)



### 服务开发篇 (34-46)

![network-layer.png](img/geektime202410/network-layer.png)


```markdown
今天我们从流量调度谈起，聊了几种典型的调度手段和负载均衡的方式。

从流量调度角度来说，负载均衡的最大价值是让多个业务服务器的压力均衡。这里面隐含的一个前提是负载均衡软件的抗压能力往往比业务服务器强很多（为什么？欢迎留言讨论）。

这表现在：其一，负载均衡的实例数/业务服务器的实例数往往大大小于1；其二，DNS 的调度不均衡，所以负载均衡的不同实例的压力不均衡，有的实例可能压力很大。

当然，负载均衡的价值并不只是做流量的均衡调度，它也让我们的业务服务器优雅升级成为可能。
```

---

```markdown
那么，桌面程序和服务端程序的差别在哪？

它们最大的差别是业务状态的表示不同。

桌面程序的业务状态是如何表示的？内存中的数据结构。我们在上一章中提到，桌面程序的 Model 层是一棵 DOM 树，根结点通常叫 Document。这棵 DOM 树其实就是桌面程序的业务状态。

服务端程序的业务状态如何表示？用内存中的数据结构可以吗？

答案当然是不能。如果业务状态在内存中，服务端程序一挂，数据就丢了。

前面我们在 “[34 | 服务端开发的宏观视角]” 提到过：

服务端的领域特征是大规模的用户请求，以及 24 小时不间断的服务。

这句话是理解服务端体系架构的核心，至关重要。但某种意义上来说更重要的原则是：

坚决不能丢失用户的数据，即他认为已经完成的业务状态。

服务端对用户来说是个黑盒，既然用户收到某个 “网络API请求” 成功的反馈，那么他会认为这个成功是确认的。

所以，服务端必须保证其业务状态的可靠性。这与桌面程序不同，桌面程序往往需要明确的用户交互事件，比如 Ctrl+S 命令，来完成数据的存盘操作，这时业务状态才持久化写入到外存。而且对于大部分桌面程序来说，它并不需要支持持久化。
```


***“三高”是BE的基本需求，也是相较于FE的特征。***

---

```markdown
存储即数据结构。

存储中间件是什么？存储中间件就是 “元数据结构”。

这个结论的逻辑在于下面几个方面。

首先，和桌面开发不同，桌面端的数据结构基本上都是基于内存的，实现难度较低。但是在服务端不同。我们每一次的业务状态改变都需要考虑持久化，所以服务端的核心数据结构都是基于外存的。

其次，服务端的数据结构对稳定性要求、并发性能（IOPS）要求极高。简单分析就可以知道，服务端程序的伸缩能力完全取决于存储的伸缩能力。

业务服务器往往是无状态的，压力大了新增加一台业务服务器非常容易。但是存储压力大了，并不能简单加一台机器了事，可能涉及数据的重新划分和搬迁工作。

这意味着，在服务端实现一个数据结构是非常困难的。我们举一个很简单的例子，在内存中我们实现一个 KV 存储非常容易，很多语言都有 Dictionary 或者 Map 这样的数据结构来做这事。就算不用库，我们自己花上几十分钟或一个小时来实现，也是非常轻松的一件事情。

但是，一个服务端的 KV 存储非常非常复杂，绝非一个人花上一天两天就可以干出来。就算干出来了，也没人敢立刻投入使用，需要经过非常庞大的测试案例进行方方面面的验证，才敢投入生产环境。并且，即使敢投入生产环境了，为了以策万全，刚开始往往也是采用“双写”的方式：同时使用一个成熟存储系统和我们新上线的存储。

存储系统的品控，至关重要。

正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。

存储中间件会有多少？

这与服务端开发的模型抽象有关。今天没有比较系统性的理论告诉大家，有了这样一些数据结构就完备了。但是从更长远发展的角度来看，我们很可能需要回答这个问题。

所以，存储中间件是 “元数据结构”。

这里说的 “元数据结构”，是我自己发明的一个词。它表达的含义是，数据结构的种类是非常有限的，并且最好理论可被证明，有了这样一些基本的数据结构，所有的业务需求都可以高效地实现。这些基本的数据结构，就是我说的 “元数据结构”。

今天我们接触的存储中间件有哪些？不完整的列表如下：

键值存储（KV-Storage）；
对象存储（Object Storage）；
数据库（Database）；
消息队列（MQ）；
倒排索引（SearchEngine）；
等等。
目前看，存储中间件的种类是不可枚举的。但它很可能只是受限于我自己的认知，也许有一天我们能够在这个问题上找到更加完美的答案。
```

“正因为服务端的数据结构实现如此之难，所以对于服务端来说，所有业务需要涉及的数据结构都需要抽象出来，成为一个存储中间件。”

在作者看来，“存储中间件是 “元数据结构””，存储中间件也是一种数据结构，还是“元数据结构”。也就是说，这些“存储中间件”的本质其实就是某种做成了服务的“数据结构”，来进行远程调用。也举出了一些例子，比如说，kvbd其实就是kv，es本质就是倒排索引。这个说法，其实是从数据结构的角度来看各种database，当然，这个观点，也是作者从BE和FE的比较中得来的。

---



```markdown
缓存（Cache）和存储（Storage）是什么关系？它也是一种存储中间件么？

既是也不是。

首先，缓存和一般的存储中间件一样，也在维持着业务状态。从这个角度看，缓存的确是一类存储。

但是，缓存允许数据发生丢失，所以缓存通常是单副本的。一个内存缓存的集群挂了一个实例，或者一个外存缓存的集群坏了一块硬盘，单就缓存集群本身而言，就出现数据丢失。

...

回到前面的问题，缓存（Cache）和存储（Storage）到底是什么关系？

我个人认为，缓存其实应该被认为是存储的补丁，而且是理论上来说不太完美的补丁。

为什么说它是补丁？

因为如果存储本身非常匹配业务场景的话，它不应该需要缓存在它前面挡一道，内部自己就有缓存。至于把一个复杂的 F(x) 缓存起来，更根本的原因还是存储和业务场景不那么直接匹配所致。

但是实现一个存储很难，所以存储的业务场景匹配性很难做到处处都很好。

出现事务（Transaction），是为了改善存储的业务场景“写操作”的匹配性，把一个复杂操作包装成一个原子操作。

出现缓存（Cache），则是为了改善存储的业务场景“读操作”的匹配性，提升高频读操作的效率。

所以我们说，缓存是一个存储的补丁。

那么为什么我们说这是一个不太完美的补丁呢？

因为上面的 FastF(x) 并没有被包装成一个原子的读操作。从严谨的角度来说，这段代码逻辑是有问题的，它会破坏数据的一致性。

对于一个确定的 x 值，如果 F(x) 永远不变，这就没问题。但如果 F(x) 值会发生变化，会有多个版本的值，那就有可能会出现并发的两个 F(x) 请求得到的结果不同，从而导致缓存中的值和存储中的值不一致。

这种情况后果有可能会比较严重。尤其是如果我们有一些业务逻辑是基于 FastF(x) 得到的值，就有可能会出现逻辑错乱。

```

“需要cache，归根到底还是因为storage和业务场景本身不匹配造成的”

这个观点太棒了，也确实如此


解答了我之前的一个问题

kvdb 和 local cache 有啥区别

因为


---

```markdown
首先，缓存和一般的存储中间件一样，也在维持着业务状态。从这个角度看，缓存的确是一类存储。

但是，缓存允许数据发生丢失，所以缓存通常是单副本的。一个内存缓存的集群挂了一个实例，或者一个外存缓存的集群坏了一块硬盘，单就缓存集群本身而言，就出现数据丢失。

缓存数据丢失，这事可大可小。只要不是发生大片大片的缓存数据丢失的情形，通常只是会造成后端存储（Storage）的短时压力变大。

但在极端的情况下，可能会出现雪崩的情况。

雪崩怎么形成？首先是部分缓存实例宕机，导致缓存命中率（Cache Hit Rate）下降，大量的请求落到后端存储上，导致后端存储过载，也出现宕机。

这时就会出现连锁反应，形成雪崩现象。后端存储就算重新启动起来，又会继续被巨大的用户请求压垮，整个系统怎么启动也启动不了。

应该怎么应对雪崩？最简单的办法，是后端存储自己要有过载保护能力。一旦并发的请求超过预期，就要丢弃部分请求，以减少压力。
```

这里对cache avalanche的过程描述不错



---


```markdown
...

这些都让 Redis 看起来更像一个数据库类的存储中间件。

但当我们把 Redis 看作存储，我们有这样一些重要的问题需要考虑。这些问题非常非常重要，存储系统可不是闹着玩的。

问题一，是持久性（Durability）。Redis 毕竟是基于内存的存储，虽然它也支持定期写到外存中，但是定期持久化的策略对于一个服务端的存储系统来说是不合格的。因为如果发生宕机，上一次持久化之后的新数据就丢了。

所以 Redis 需要其他的提升持久性的方案，比如多副本。

Redis 的确支持多副本。但是只是同机房多台机器的多副本是没有用的，因为它没有办法防止机房整体断电这类的故障。当出现机房级的故障时，就有极大概率会丢失数据。

对于存储系统来说，这是不可接受的。因为相比人们对持久性的要求，机房整体断电并不是一个太小概率的事件。

所以 Redis 如果要作为存储的话，必须保证用多机房多副本的方式，才能保证在持久性这一点上能够达标。

但是多机房多副本这样的方式，显然实施条件过于苛刻。会有多少企业仅仅是为了部署 Redis 去搞多个机房呢？

问题二，是重试的友好性。在 “[29 | 实战（四）：怎么设计一个“画图”程序？]” 中我们提到过，考虑网络的不稳定性，我们设计网络协议的时候需要考虑重试的友好性。

在 Redis 的协议中，有不少请求用户很友好，但是对重试并不友好。比如，LPUSH 请求用来给列表（List）增加一个元素。但是在重试时一个不小心，我们很可能就往列表中添加了多个相同的元素进去。

总结来说，Redis 如果我们把它作为存储的话，坑还是不少的。它和 memcached 都是实用型的瑞士军刀，很有用，但是我们站在分布式系统的理论角度看时，它们都有那么一点不完美的地方。
```

这里从分布式系统的角度出发，给redis本身挑了两个错：

- redis的多副本机制，只能保证同机房，无法保证跨机房。所以如果整个IDC出现问题，那就完蛋了。（当然这种情况的话，数据是不是本身也持久化道本地了，数据本身问题不大，只是服务挂了？）
- redis的写操作不支持幂等性？因为list本身就支持添加重复数据啊，相应的，set、zset就不支持添加重复数据。这个是ds本身就要求的。

所以，可能这两点其实也不太成立？


---


[45 架构：怎么做详细设计？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/45%20%e6%9e%b6%e6%9e%84%ef%bc%9a%e6%80%8e%e4%b9%88%e5%81%9a%e8%af%a6%e7%bb%86%e8%ae%be%e8%ae%a1%ef%bc%9f.md)


```markdown
实现：数据结构+算法
聊完使用界面，接下来就要谈实现原理了，它要体现的是我如何做到。

在 “[42 | 实战（二）：“画图”程序后端实战]” 一讲中，我们提到过以下这个大家耳熟能详的公式：

程序 = 数据结构 + 算法

它是一个很好的指导思想。当我们谈程序的实现时，我们总是从数据结构和算法两个维度去描述它。

我们先看数据结构。

数据结构从大的层面分，可分为基于内存的数据结构，和基于外存（比如 SSD 盘）的数据结构。

对于桌面程序，大部分情况下我们打交道的都是基于内存的数据结构。外存数据结构也会有所涉及，但往往局限于 IO 子系统。

但对于服务端程序，数据结构不完全是我们自己能够做主的。数据结构大部分情况下都是基于外存的，而且有极高的质量要求。
```

程序 = 数据结构 + 算法


```markdown
在 “[36 | 业务状态与存储中间件]” 这一讲中我们也说过，存储即数据结构。所以，服务端程序在数据结构这一点上，最为重要的一件事是选择合适的存储中间件。然后我们再在该存储中间件之上组织我们的数据。

这是数据库这样的存储中间件流行起来的原因。无论是关系型数据库，还是文档型数据库，他们都被设计为一种泛业务场景的数据结构，有很好的业务适应性。

所以在服务端我们谈数据结构，谈的不是内存数据结构，往往谈的是数据库的表结构设计。当然表（Table）是在关系型数据库中的说法，在 mongodb 中我们叫集合（Collection）。但不管我们用的是哪种数据库，出于惯例我们往往还是以 “定义表结构” 一词来表达我们想干什么。

描述表结构，核心需要包含以下内容：

字段名；
类型；
字段含义，以及是否指向另一个表的某个字段；
索引。


你会发现，其实定义表结构和定义内存数据结构本质是完全一致的。定义内存中的一个类（或结构体），我们也关心字段名（成员变量名）和类型，也关心字段的含义，以及它是否指向另一个类（或结构体）的某个字段（成员变量）。

但表结构比内存数据结构多了一个概念：索引。

索引为何存在？我认为有这样几方面的原因。一方面是因为数据库是泛业务场景的通用数据结构，它是动态的，需要依赖索引来提升数据访问的效率。另一方面是因为多租户。多租户导致数据量的爆发式增长，导致大部分情况下遍历查找变得不现实。

索引怎么设计？它完全取决于算法。算法里面使用了哪些数据访问的特征，这些数据访问的频次预期是多少，这些决定了我们添加哪些索引是最划算的。

在涉及的类比较多，或数据库的表结构比较复杂的时候，有时我们会用 UML 类图来对数据结构进行直观的呈现。

谈清楚了数据结构，我们接着聊算法。

在 “程序 = 数据结构 + 算法” 这个说法中，“算法” 指的是什么？在 “[42 | 实战（二）：“画图”程序后端实战]” 一讲中，我们这么说：

在架构过程中，需求分析阶段，我们关注用户需求的精确表述，我们会引入角色，也就是系统的各类参与方，以及角色间的交互方式，也就是用户故事。

到了详细设计阶段，角色和用户故事就变成了子系统、模块、类或者函数的使用界面（接口）。我们前面一直在强调，使用界面（接口）应该自然体现业务需求，就是强调程序是为用户需求服务的。而我们的架构设计，在需求分析与后续的概要设计、详细设计等过程之间也有自然的延续性。

所以算法，最直白的含义，指的是用户故事背后的实现机制。

数据结构 + 算法，是为了满足最初的角色与用户故事定义，这是架构的详细设计阶段核心关注点。
```



“程序 = 数据结构 + 算法” 是我们很熟悉的一个公式。它其实是怎么描述实现原理的很好的指导方针。当我们谈程序的实现时，我们总是从数据结构和算法两个维度去描述它。


“程序 = 数据结构 + 算法”这一公式被用来指导详细设计的过程。数据结构是程序中数据的组织和存储方式，它决定了数据如何在系统中被管理，包括在内存中或数据库等外存中的组织形式。算法则是操作这些数据结构的方法和步骤，它定义了如何通过一系列指令来解决问题或完成任务。在详细设计中，设计者需要明确系统的使用界面，即系统或模块如何被其他部分使用，同时也要描述数据如何在系统中流动和被处理，这涉及到选择合适的数据存储结构和定义操作数据的算法。简而言之，程序设计不仅仅是编写代码，更重要的是设计合理的数据结构和高效的算法，以确保程序能够有效地满足业务需求并运行高效。

应该说，这是一个高度抽象的概括。


















### 服务治理篇 (47-56)

[47 服务治理的宏观视角](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/47%20%e6%9c%8d%e5%8a%a1%e6%b2%bb%e7%90%86%e7%9a%84%e5%ae%8f%e8%a7%82%e8%a7%86%e8%a7%92.md)

```markdown
我们的期望，是把服务治理建立成自治系统，而不是简单的自动化系统。

基于这样的思考，人们逐渐建立了基于物理机器资源的服务治理体系。脚本成为了平台。而平台的形成，正是脚本的抽象化、产品化、普适化的结果。

把一个服务实例绑定在某一台物理的服务器，虽然让服务视图看起来很直观，但是这种绑定让我们应对物理资源故障变得被动，同时也不利于服务器资源的充分利用。

所以虚拟机和容器技术的诞生，促使人们开始探索物理资源和应用服务之间的解耦。而一旦我们完成了这一步，服务的逻辑视图就完全语义化了，它与物理资源就只是一个应用的过程。物理资源环境发生任何故障，都可以迅速在新的硬件设备上重新构建。

对 SRE 来说，机器的损坏和生命周期管理基本上已经不需要任何操作了。硬件已经被池化。成千上万的机器加入系统，或者出现问题，被修复，这一切都不需要 SRE 的任何操作。

这意味着，随着系统的层次结构不断上升，我们完成了从手动触发，到自动触发，到自主化。
```

---

[48 事务与工程：什么是工程师思维？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/48%20%e4%ba%8b%e5%8a%a1%e4%b8%8e%e5%b7%a5%e7%a8%8b%ef%bc%9a%e4%bb%80%e4%b9%88%e6%98%af%e5%b7%a5%e7%a8%8b%e5%b8%88%e6%80%9d%e7%bb%b4%ef%bc%9f.md)



```markdown
什么才是真正的工程师文化？

从浅层的意义来说，工程师就是要实现业务的自动化。DON’T REPEAT YOURSELF! 某件重复发生的事情只干一次就好，以后也不需要再重复做。

工程师的自动化思维，所体现的内在逻辑是如何把问题 Close，如何把问题彻底解决掉，而编码只是一种工具。

在我们日常生活中，很多问题不需要编码来解决，但是确实需要用 “彻底解决它” 的思维去完成。这种思维不仅限于工程师，同样适用于所有人。比如，我们开餐厅需要解决服务质量的问题，这一点可能海底捞就解决得很好，但是不一定是用编码的方式解决。同样地，假设我们办线下市场活动，要解决内容质量的问题。怎么彻底解决它，这是值得深度思考的问题。

很多人会习惯呆在自己的舒适区，习惯于做任务，每天重复相同的作业，这就不符合我们所说的 “工程师文化”。我们需要达到的状态是，今天干完一件事，明天开启新的事。

怎么判断自己在做新的事情？那就要看我们问题是否解决得够彻底。

比如我在做新媒体运营，每天写着不同的公众号文章，这是否代表我在做新的事情？答案显然是不一定。要回答这个问题，我们首先需要搞清楚的是，我每天发公众号文章，是在解决一个什么样的问题。如果我们没有想清楚这一点，那么我们就不是在 Close 问题，我们只是在做任务而已。

我们的目标显然不应该是每天发一篇文章。这是在定义一件事务，而不是定义一个目标。把问题定义清楚非常非常重要。清楚了问题，就是设定清楚了我们的目标。然后才能谈得上去彻底解决掉它。

从另一个维度看，工程师这种把问题 Close，彻底解决掉的思维，看重的是自己工作内容的长期价值。如果我们只是在做事务，如果我们并没有在实质性解决一个问题，那么这件事情的长期价值就是零。


所以本质上，工程师文化也是产品文化，把问题以一种自动化的方式解决。 这才是我们真正应该尊崇的工程师文化。

一个公司各个岗位是彼此协作的团队，工程师并不是特殊群体。销售、技术支持、产品、开发工程师每一个角色都是平等的。每个人都应该秉承工程师精神，把一个个问题 Close，让它不要再发生。不需要显得很忙，忙不代表成就，真正的工程师文化应该是推动整个团队往前走，每个团队成员都在成长。
```

“怎么判断自己在做新的事情？那就要看我们问题是否解决得够彻底。”

要 close问题，而不是解决问题

***其实也就是老生常谈的“更深一步”，fix了bug之后，还要挖掘bug真正的成因在什么地方？哪里的知识点有问题？team的开发规范/工作流程有问题？还是更深层次的团队文化问题？ 解决生活中的问题同样。我觉得这个不是反思，***

---

[52 故障排查与根因分析](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/52%c2%a0%e6%95%85%e9%9a%9c%e6%8e%92%e6%9f%a5%e4%b8%8e%e6%a0%b9%e5%9b%a0%e5%88%86%e6%9e%90.md)

```markdown
从理论上讲，我们将故障排查过程定义为反复采用“假设-验证排除”手段的过程：针对某系统的一些观察结果和对该系统运行机制的理论认知，我们不断提出一个造成系统问题的假设，进而针对这些假设进行测试和排除。

为了有效排查故障，日志系统在里面起到了关键作用。定位问题本身就是 “假设-验证排除-再假设-再验证排除” 这样的循环，直至最后定位到问题。所以基于时序数据的日志系统，往往查询支持非常多样化的过滤条件，功能非常强大。
```

---


[56 服务治理篇：回顾与总结](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/56%20%e6%9c%8d%e5%8a%a1%e6%b2%bb%e7%90%86%e7%af%87%ef%bc%9a%e5%9b%9e%e9%a1%be%e4%b8%8e%e6%80%bb%e7%bb%93.md)

```markdown
服务端的话题被我分为了两章：“服务端开发篇” 与 “服务治理篇”。它们的边界在于，服务端开发致力于设计合适的业务架构来满足用户需求，而服务治理则致力于让服务端程序健康地为客户提供 7x24 小时不间断的服务。
```

```markdown
...

Docker 出现后，紧接着 CoreOS 也推出了新的服务端操作系统。CoreOS 是专注于服务端的操作系统，它认为除了只读的操作系统内核外，所有的软件都应该是基于容器发布的。

这种思想很先进。但无奈的是，它一方面对用户习惯改变过大，另一方面也没有真正切中用户最关键的痛点，导致它一直没能够流行起来。

从商业角度来说，早期 Docker 和 CoreOS 表现得很互补的样子，但是双方的商业目标其实相同，都是希望能够成为数据中心操作系统（DCOS）的领导者。

所以，Docker 推出了 Docker Swarm，而 CoreOS 也有自己的集群版。这下，两家公司的友好协作的表象很快就被打破了。

但最后，Google 牵头推 Kubernetes，结束了 DCOS 之争。当然这事今天来重新回顾，它也在情理之中，毕竟容器技术实际上最早是在 Google 推动下被加入 Linux 内核，而它内部更是有 Borg 这样的 DCOS 系统，有着丰富的基于容器的服务治理实践经验。

无论是 Docker 还是 CoreOS，两家公司都大大低估了 DCOS 这件事情的难度。当然这事低估的并不只是他们，也包括七牛云。在 Docker 诞生后，我们就意识到 DCOS 是未来，所以 2014 年我们就成立了 QCOS 项目组来做这事，但最终这个项目组转向了拥抱 Kubernetes。
```

CoreOS 是专注于服务端的操作系统，它认为除了只读的操作系统内核外，所有的软件都应该是基于容器发布的。


![service-governance.png](img/geektime202410/xsw-chapter-4.png)


---


```markdown
今天我们对本章内容做了概要的回顾，到此为止，我们 “基础平台”、“桌面开发”、“服务端开发”、“服务治理” 这四大模块就结束了。从工程师架构设计角度来说，它们基本上涵盖了我们会打交道的绝大部分通用业务场景。

理解了这几章的内容，整个软件大厦的骨架就可以明了了。

下一步应该学什么？架构思维原则？或者是设计模式？

架构思维的确是有很多共性的东西，值得我们总结出来细细体会。比如 “开闭原则”，多么有力的架构思维的总结，值得我们时时拿出来提醒自己。

不过，我个人不太喜欢常规意义上的 “设计模式”。或者说，我们对设计模式常规的打开方式是有问题的。理解每一个设计模式，都应该放到它想要解决的问题域来看。所以，我个人更喜欢的架构范式更多的是 “设计场景” 的总结。“设计场景” 和设计模式的区别在于它有自己清晰的问题域定义，是一个实实在在的通用子系统。

是的，这些 “通用的设计场景”，才是架构师真正的武器库。如果我们架构师总能把自己所要解决的业务场景分解为多个 “通用的设计场景” 的组合，这就代表架构师有了极强的架构范式的抽象能力。而这一点，正是架构师成熟度的核心标志。
```
















### 架构思维篇 (57-67)

[58 如何判断架构设计的优劣？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/58%c2%a0%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e7%9a%84%e4%bc%98%e5%8a%a3%ef%bc%9f.md)

```markdown
架构设计的基本准则
架构设计会有它的一些基本准则。比如：

KISS：简单比复杂好；
Modularity：着眼于模块而不是框架；
Testable：保证可测试性；
Orthogonal Decomposition：正交分解。
KISS 全称是 Keep it Simple, Stupid，用最直白的话说，“简单就是美”。不增加无谓的复杂性。正确理解系统的需求之后才进行设计。要避免过度设计，除非有人为复杂性买单。

KISS 的“简单”，强调的是易实施性。让模块容易实现，实现的时候心智负担低，比复杂的优化更重要。

KISS 的“简单”，也是主张让你的代码，包括接口，符合惯例。接口语义要自然，最好让人一看方法名就知道怎么回事，避免惊异。

Modularity，强调的是模块化。从架构设计角度来说，模块的规格，也就是模块的接口，比模块的实现机制更重要。

我们应着眼于模块而不是框架。框架是易变的。框架是业务流，可复用性相对更低。框架都将经历不断发展演化的过程，逐步得到完善。

所以不让模块为框架买单。模块设计时应忽略框架的存在。认真审视模块的接口，发现其中“过度的（或多余的）” 约束条件，把它提高到足够通用的、普适的场景来看。

Testable，强调的是模块的可测试性。设计应该以可测试性为第一目标。

可测试往往意味着低耦合。一个模块可以很方便地进行测试，那么就可以说它是一个设计优良的模块。模块测试的第一步是环境模拟。模块依赖的模块列表、模块的输入输出，这些是模块测试的需要，也是模块耦合度的表征。

当然，可测试性不单单因为是耦合的需要。测试让我们能够发现模块构架调整的潜在问题。通常模块在架构调整期（代码重构）最容易引入 Bug。 只有在模块开发过程中我们就不断积累典型的测试数据，以案例的形式固化所有已知 Bug，才可能在架构调整等最容易引发问题的情形下获得最佳的效果。

Orthogonal Decomposition，中文的意思是 “正交分解”。架构就是不断地对系统进行正交分解的过程。

相信大家都听过一个设计原则：“优先考虑组合，而不是继承”。如果我们用正交分解的角度来诠释这句话，它本质上是鼓励我们做乘法而不是做加法。组合是乘法，它是让我们用相互正交、完全没有相关性的模块，组合出我们要的业务场景。而继承是加法，通过叠加能力把一个模块改造成另一个模块。

```

***架构设计的基本准则：KISS, 模块化、可测试、正交性***

需要注意的是，这里的模块化，指的是“应该着眼于模块，而不是框架”。按我的理解，各种pkg其实就可以看作是某种“模块化”的实践。但是，除此之外，各种业务代码本身就是与项目耦合的，恐怕很难模块化吧？还是说微服务也可以看作是该准则的实践？

---


```markdown
核心系统的伤害值
正交分解，第一件事情就是要分出哪些是核心系统，哪些是周边子系统。核心系统构成了业务的最小功能集，而后通过不断增加新的周边功能，而演变成功能强大的复杂系统。

对于核心系统的变更要额外小心。如果某新功能早期没有规划，后期却被界定为属于核心功能，我们就需要认真评估它对既有架构的破坏性。
```



![chapter-4.png](img/geektime202410/xsw-chapter-4.png)



### 软件工程篇 (68-77)



[70 怎么写设计文档？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/70%20%e6%80%8e%e4%b9%88%e5%86%99%e8%ae%be%e8%ae%a1%e6%96%87%e6%a1%a3%ef%bc%9f.md)



---


[71 如何阅读别人的代码？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e8%ae%b8%e5%bc%8f%e4%bc%9f%e7%9a%84%e6%9e%b6%e6%9e%84%e8%af%be/71%c2%a0%e5%a6%82%e4%bd%95%e9%98%85%e8%af%bb%e5%88%ab%e4%ba%ba%e7%9a%84%e4%bb%a3%e7%a0%81%ef%bc%9f.md)














### 总结


传道授业。许式伟这本书更多传达出的是，作为架构师，应该怎么思考，倒不涉及太多真正技术细节相关的东西。也就是更多是“传道”，而非“授业”。这在现在各种“教程类”的技术书里，也是独树一帜了。






## 《架构设计面试精讲》

[架构设计面试精讲](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2) 没啥意思，3到8是分布式系统相关问题；9到12是mysql相关；13、14是redis相关；15到19是一些面试中系统设计相关问题

---




### 分布式系统 (3-8)





### 系统设计 (15-19)








### 总结





## ~~《从 0 开始学架构》~~

[从 0 开始学架构](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84) 快速过了一下，内容都是浅尝辄止，所以跳读查缺补漏一下


---

[24 FMEA方法，排除架构可用性隐患的利器](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/24%20FMEA%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%92%E9%99%A4%E6%9E%B6%E6%9E%84%E5%8F%AF%E7%94%A8%E6%80%A7%E9%9A%90%E6%82%A3%E7%9A%84%E5%88%A9%E5%99%A8.md)

FEMA = Failure mode and effects analysis

故障模式与影响分析


在软件架构设计中，怎么实践FMEA？都有哪些步骤？



---

[19 单服务器高性能模式：Reactor与Proactor](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/19%20%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%AB%98%E6%80%A7%E8%83%BD%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor%E4%B8%8EProactor.md)



---

[23 想成为架构师，你必须掌握的CAP细节](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/23%20%E6%83%B3%E6%88%90%E4%B8%BA%E6%9E%B6%E6%9E%84%E5%B8%88%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84CAP%E7%BB%86%E8%8A%82.md)










## ~~《周志明的架构课》~~

[周志明的架构课](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%91%A8%E5%BF%97%E6%98%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE)

---







## ~~《高并发系统设计40问》~~

[高并发系统设计40问](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A140%E9%97%AE)

---










## ~~《由浅入深吃透 Docker》~~


[由浅入深吃透 Docker-完](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E5%90%83%E9%80%8F%20Docker-%E5%AE%8C) 看的时候才发现很久之前看过，实际上这本册子就是从 docker官方文档里摘录出来的，初学者可以看看

---



## ~~《深入浅出 Docker 技术栈实践课》~~

[深入浅出 Docker 技术栈实践课（完）](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Docker%20%E6%8A%80%E6%9C%AF%E6%A0%88%E5%AE%9E%E8%B7%B5%E8%AF%BE%EF%BC%88%E5%AE%8C%EF%BC%89) 太水了

---








## ~~***《容器实战高手课》***~~

[容器实战高手课](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%AE%B9%E5%99%A8%E5%AE%9E%E6%88%98%E9%AB%98%E6%89%8B%E8%AF%BE) 本书的核心是

```markdown
00 开篇词 一个态度两个步骤，成为容器实战高手.md
01 认识容器：容器的基本操作和实现原理.md
02 理解进程（1）：为什么我在容器中不能kill 1号进程？.md
03 理解进程（2）：为什么我的容器里有这么多僵尸进程？.md
04 理解进程（3）：为什么我在容器中的进程被强制杀死了？.md
05 容器CPU（1）：怎么限制容器的CPU使用？.md
06 容器CPU（2）：如何正确地拿到容器CPU的开销？.md
07 Load Average：加了CPU Cgroup限制，为什么我的容器还是很慢？.md
08 容器内存：我的容器为什么被杀了？.md
09 Page Cache：为什么我的容器内存使用量总是在临界点.md
10 Swap：容器可以使用Swap空间吗？.md
11 容器文件系统：我在容器中读写文件怎么变慢了？.md
12 容器文件Quota：容器为什么把宿主机的磁盘写满了？.md
13 容器磁盘限速：我的容器里磁盘读写为什么不稳定_.md
14 容器中的内存与IO：容器写文件的延时为什么波动很大？.md
15 容器网络：我修改了_proc_sys_net下的参数，为什么在容器中不起效？.md
16 容器网络配置（1）：容器网络不通了要怎么调试.md
17 容器网络配置（2）：容器网络延时要比宿主机上的高吗.md
18 容器网络配置（3）：容器中的网络乱序包怎么这么高？.md
19 容器安全（1）：我的容器真的需要privileged权限吗.md
20 容器安全（2）：在容器中，我不以root用户来运行程序可以吗？.md


加餐01 案例分析：怎么解决海量IPVS规则带来的网络延时抖动问题？.md
加餐02 理解perf：怎么用perf聚焦热点函数？.md
加餐03 理解ftrace（1）：怎么应用ftrace查看长延时内核函数？.md
加餐04 理解ftrace（2）：怎么理解ftrace背后的技术tracepoint和kprobe？.md
加餐05 eBPF：怎么更加深入地查看内核中的函数？.md
加餐06 BCC：入门eBPF的前端工具.md
结束语 跳出舒适区，突破思考的惰性.md
```


[chengyli/training](https://github.com/chengyli/training) 这个教程的对应repo


---

[02 理解进程（1）：为什么我在容器中不能kill 1号进程？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%ae%b9%e5%99%a8%e5%ae%9e%e6%88%98%e9%ab%98%e6%89%8b%e8%af%be/02%20%e7%90%86%e8%a7%a3%e8%bf%9b%e7%a8%8b%ef%bc%881%ef%bc%89%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e5%9c%a8%e5%ae%b9%e5%99%a8%e4%b8%ad%e4%b8%8d%e8%83%bdkill%201%e5%8f%b7%e8%bf%9b%e7%a8%8b%ef%bc%9f.md) 我知道容器内不能kill掉init进程，如果想重启k8s pod的话，应该用 kubectl rollout restart

---

[03 理解进程（2）：为什么我的容器里有这么多僵尸进程？](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%ae%b9%e5%99%a8%e5%ae%9e%e6%88%98%e9%ab%98%e6%89%8b%e8%af%be/03%20%e7%90%86%e8%a7%a3%e8%bf%9b%e7%a8%8b%ef%bc%882%ef%bc%89%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e7%9a%84%e5%ae%b9%e5%99%a8%e9%87%8c%e6%9c%89%e8%bf%99%e4%b9%88%e5%a4%9a%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b%ef%bc%9f.md)























:::danger

用不到，暂时不看

:::





## 《csapp》以及《深入浅出计算机组成原理》


[深入浅出计算机组成原理](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bb%84%e6%88%90%e5%8e%9f%e7%90%86)


---

![csapp.png](img/geektime202410/csapp.png)


[CSAPP 第五章 优化程序性能（一）基础优化与依赖机器架构的优化 | JR's Blog](https://willendless.github.io/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2021/06/29/csapp-ch5/)

[CSAPP 第五章 优化程序性能（一）基础优化与依赖机器架构的优化 | JR's Blog](https://willendless.github.io/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2021/06/29/csapp-ch5/)

[优化程序性能的几个方法（来自于《深入理解计算机系统》）-阿里云开发者社区](https://developer.aliyun.com/article/396481)


```yaml

#- [ ] 分布式中间件实践之路（完）
#- [ ] 分布式技术原理与实战 45 讲 - 完
#- [ ] 24 讲吃透分布式数据库 - 完
#- [ ] 300 分钟吃透分布式缓存 - 完

```




```yaml
  qs:
    - q: “三高架构”
      x: |
        高并发：

        - *扩容*
        - 无状态
        - 拆分
        - 服务化
        - 消息队列
        - 数据异构
        - 缓存银弹
        - 并发化（异步并发）
        - 连接池
        - 线程池
        - 分布式任务

        高可用：

        - 系统高可用的核心是`备份 + 自动切换`
        - 如果压力（不只是数据库或者服务器，各个层的压力）太大，考虑做“集群”，所以，也可以认为是`集群 + 自动切换`，核心思想是“去单点”，只不过是机器多少的问题

        ---

        - 事前：副本；隔离；配额，提前预案，探知
        - 事发：监控和报警
        - 事中：降级，回滚，应急预案，fairXXX 系列
        - 事后：复盘，思考，技改

        ---

        - `熔断`，通过隔离实现故障隔离
        - `降级`，通过降级实现部分可用，有损服务
        - `回滚`，通过回滚机制快速修复错误版本
        - `限流`，通过“限流”保护服务受到雪崩的影响
        - `切流量`
        - `兜底容灾`


    - q: 怎么理解DDD
      x: 一般 ddd 会划分几个领域，核心域 (核心业务），通用域 (比如用户中心），支撑域 (比如 MySQL REDIS KAFKA)，ddd 最难的应该就是核心域的服务拆分，但是不管怎么拆分每个服务一般都有自己的缓存 (Redis），持久化 (mySQL)，事件（katka)，服务与服务之间一般通过事件做通信

```




```yaml
    - q: "***分布式场景常见问题：分布式场景下的`分布式事务`，`幂等控制`，`异步消息乱序`，和`补偿方案`等问题？***"
      x: |
        目前的主流方案是 *`待处理内容写入本地表`+`事务外实时触发`+`定时调度补偿`* ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理

        - 分布式事务
          - 事务中直接 RPC 调用达到强一致性
          - 事务中进行异步消息推送
          - 解决方案
          - 目前我们使用的解决方案
        - 幂等控制
        - 异步消息乱序
          - 异步消息结合状态驱动
        - 补偿方案
          - `HTTP同步调用的补偿`
          - `异步消息消费失败的补偿`

    - q: 如何解决时间漂移问题在多处理器系统、分布式系统中带来的时序相关的问题？在分布式系统中，怎么使用逻辑时钟和向量时钟？这两种方案做个比较。哪种方法更好呢？
      u: https://www.hitzhangjie.pro/blog/2021-03-09-%E8%81%8A%E8%81%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/
      x: 分布式数据库、分布式锁等场景使用向量时钟。向量时钟相比逻辑时钟更加复杂。

    - q: most common problems in distributed scenarios? How to resolve?
      x: distributed transactions, idempotent control, async msg out-of-order, compensation schemes
    - q: "***分布式场景下的分布式事务，幂等控制，异步消息乱序，和补偿方案等问题？***"
      x: 目前的主流方案是 *`待处理内容写入本地表`+`事务外实时触发`+`定时调度补偿`* ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理


    - q: 服务治理（包括但不限于：限流，熔断、负载、监控、鉴权、服务发现和注册等等）
    - q: 服务容错（失败切换（failover），失败通知（failback），失败缓存（failcache）， 快速失败（failfast）、双发 backuprequest）
      x: |
        服务容错的常用手段：

        #FailOver 失败自动切换
        服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试次数。要求服务调用幂等，不管调用多少次，只要是同一个调用，返回结果必须相等，适合读请求。

        #FailBack 失败通知
        消费者调用失败后，不再重试。而是根据失败的详细信息，决定后续的执行策略。对于非幂等的调用场景，不能重试，而是应该查询服务端状态，看调用到底是否实际生效。

        #FailCache 失败缓存
        服务消费者调用失败或者超时后，不立即重试，而是间隔一段时间再次尝试发起调用。

        #FailFast 快速失败
        消费者调用一次失败后，不再重试。一般非核心业务调用，采用快速失败，记录日志后就返回。

        一般幂等的使用FailOver或者FailCache，不是幂等调用选择FailBack或者FailFast。

```





为什么很多分布式系统都是以DAG（Directed acyclic graph ）实现运算的？



## ~~《分布式中间件实践之路》~~

[分布式中间件实践之路（完）](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89)

---




## ***《分布式技术原理与实战45讲》***

[分布式技术原理与实战45讲-完](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%9845%E8%AE%B2-%E5%AE%8C) 1-6是分布式基础；7-13是分布式事务；14-22是分布式服务；23-29是分布式存储；30-37是MQ；38-44是分布式缓存；44-52是分布式高可用


![distributed-system.png](img/geektime202410/distributed-system.png)

```markdown
本课程分为 7 个模块，共 45 讲。我将从实际工作和面试出发，从分布式理论开始带你建立知识框架，然后逐个攻破分布式技术的各个核心技术领域。为了让你更清晰地了解本课程中的所有知识点，我还准备了一份思维导图：

分布式基础：扎实的理论是进一步学习分布式知识的钥匙，这一模块将详解分布式的概念，包括 CAP 和 Base 理论、各种数据一致性模型，以及两阶段和三阶段提交协议等。

分布式事务：在电商、金融等业务中都涉及资金往来，事务非常重要，那么分布式事务如何解决、分布式锁如何实现、……，这一模块将会解答。

分布式服务：分布式服务是微服务架构的必要条件，这一模块将讲解如何解决服务拆分后的一系列问题，比如 RPC、网关、注册中心等。

分布式存储：系统架构拆分以后，存储层面的拆分同样重要，数据库层涉及读写分离、分库分表等，这一模块我们来一起来探究这些技术的原理，以及如何在业务中落地。

消息队列：消息中间件是分布式系统架构的整合剂，这一模块将分享消息队列使用的常见问题，比如重复消费、消息时序等。

分布式缓存： 缓存的高性能在分布式系统中发挥了更加重要的作用，那么分布式缓存有哪些分类，以及有哪些经典问题，这一模块我们来一起探究。

分布式高可用：高可用是工程师始终追求的目标，最后这个模块，我将会为你分享在分布式系统中如何保障系统可用性，如何做好系统监控和限流降级。

```

---




## 《24讲吃透分布式数据库》

[24讲吃透分布式数据库-完](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/24%E8%AE%B2%E5%90%83%E9%80%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C) 7到12是存储引擎相关，13到23是“模块三”


```markdown
基于以上设计思路，我把课程分为 4 个模块，合计 24 讲。

模块一，分布式数据历史演变及其核心原理。从历史背景出发，讲解了分布式数据库要解决的问题、应用场景，以及核心技术特点。
模块二，分布式数据库的高性能保证——存储引擎。这是专栏的亮点内容，简要展示了现代数据库的存储引擎，比如典型存储引擎、分布式索引、数据文件与日志结构存储、事务处理。其中，我会特别介绍分布式数据库与传统数据库在存储层面上的差异。学完之后，你会对分布式数据库中的重要特性（如一致性和分布式事务）有一个完整的理解，明白为什么一些特定存储引擎（如日志结构存储）更适合去构建分布式数据库。
模块三，分布式数据库的高扩展性保证——分布式系统。详细介绍分布式数据库中所蕴含的系统设计原理、算法等，包含但不限于错误侦测、领导选举、数据可靠传播、分布式事务、共识算法等内容。虽然分布式内容很多，但我不会面面俱到，而是帮你提炼精华，基于实例为你建立知识体系。
模块四，知识拓展。我会和你探讨当代最成功的分布式数据库（传统&新型），探讨它们成功的关键，同时将它们与之前模块中所介绍的技术原理进行相应的映射，让你的知识体系更加丰富。
```

---

存储引擎这部分，以下两个视频说的更清晰

- [#115 理论结合实践详解 B+ 树存储引擎（InnoDB、BoltDB、BuntDB） - YouTube](https://www.youtube.com/watch?v=9XtACKzFIRc)
- [#116 理论结合实践详解 lsm 树存储引擎（bitcask、moss、leveldb 等） - YouTube](https://www.youtube.com/watch?v=adamqSuHHck)

这里说下我对这部分内容的总结





























## 《ElasticSearch知识体系详解》


[ElasticSearch知识体系详解](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/ElasticSearch%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3)

---











## 《etcd实战课》

[Kimi.ai - 帮你看更大的世界](https://kimi.moonshot.cn/chat/crmo515fc7u9ac67qf70) etcd

[etcd-面试题库-创脉思面试题库](https://www.cms365.cn/topic/clw8xqqg247uqaz6xj9lrvrbt)

[etcd实战课](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/etcd%E5%AE%9E%E6%88%98%E8%AF%BE)

[Etcd——大厂面试问题集合_etcd面试题-CSDN博客](https://blog.csdn.net/weixin_41605937/article/details/121920094)

etcd Linearizable Read

[Put方法 | etcd官方文档中文版](https://doczhcn.gitbook.io/etcd/index-1/kv_service/put)

---








