---
draft: true
---



如果拿图书馆来类比mysql的话，就很好理解了。假设我们的需求是进入图书馆获取n本符合我们需要的书。

- connector就相当于门卫，只有预约（相当于auth）过才能进入，我们可以通过调整连接数（就是预约人数）来动态调整图书馆的负载。
- parser就相当于图书馆的前台，是把汉语转化成该书的ISBD号等MACS专用信息（将查询语句转换为内部数据结构，相当于compiler），并且提供这些书的位置和路线（提供查询计划）。mysql的parser其实就是compiler，词法分析、语法分析啥的。
- optimizer就相当于优化我们去找到这本书的路线（找到最优路线，提高查询效率）。
- executor则相当于“图书馆操作员”，负责执行优化后的查询计划（也就是带着我们），从图书馆书架（存储引擎）里查找所有需要的数据，这也解释了查询操作关键字的执行顺序，当然要先确定这些书籍的大概区域（也就是FROM），如果需要把这些书按序排列的话，就最后再执行Order这种已经拿到所有书籍之后无关紧要的操作。那中间肯定就是来获取查找这些书了，也就是各种条件（where和groupby/having和select），当然书肯定不需要重复的（也就是Distinct去重操作）。

如果我们把存储引擎比做图书馆的所有书架的话，表、页、行分别类比成什么呢？表可以类比成图书馆的某个区域，每个区域存放着特定类型的书籍。页可以看作是该区域的某个书架，每个书架上放着一定数量的书籍。行可以类比成某一排书，每一排上放着一本书。

进一步的，我们可以用这些继续类比myisam和innodb，myisam就是每个分类（比如工业技术、交通运输、历史地理等等，具体查看《中国图书馆分类法》）都会有一个单独的目录，并且不允许很多人同时查找（不支持并发查找，也就是不支持事务），进行查找时直接锁表，相应的，我们可以直接通过这个单独的MYI索引文件查找对应的图书，非常快。

InnoDB就灵活的多了，他是以书架为单位进行查找和存储的，所以他的目录（索引）是和某排图书在一起的（相当于每排书一个索引（主键索引），索引id都贴在书架该层的最前面，这时就存在两种情况，一种就是直接查目录（索引）就可以获得数据，不需要再查数据表，这个就是“索引覆盖”（或者说Index Dive，都是类似意思）。如果目录中查不到我们需要的数据，就需要“回表”了，那么我们根据索引id来看需要的书是不是在这排（再多说一句，这也是为什么主键id最好单调递增的原因））。他是支持多人同时查找的。并且在读写操作时只锁定某排书（也就是行级锁定），粒度更细，这样就更能频繁地执行读操作和写操作。

需要注意的是mysql还支持同时使用多种存储引擎，也就是说在图书馆里如果有一些冷门分类，很少有新书入库的，那就用myisam这种类型的管理方式，如果非常热门的分类，每天都有很多用户来买书，每天书店也需要频繁补货的，就应该用innodb。当然，如果我们把mysql看作是图书馆的话，不同图书馆的特性（规矩、规章制度）也不同，比如说oracle或者sql server这种的就比较死板，图书馆开店营业之前就定好了所有书架的管理模式（也就是存储引擎），之后再也不能修改，更不存在说不同分类使用不同的管理模式一说了。

另外，还需要注意一个问题，编织目录（索引）的具体方法和该“图书分类”（存储引擎）的映射关系。众所周知，对于不同图书分类也应该使用不同的方式来编写目录。比如说R树适用于myisam（也有B+Tree），hash适用于memory，B+Tree则适用于InnoDB。









## optimizer


ICP and index dive, (MRR, BKA, BNL)

- `ICP索引条件下推(Index Condition Pushdown)` 用索引筛选的 where 条件在存储引擎一侧进行筛选，而不是将所有 index access 的结果都放在 server 端进行 where 筛选
- `MRR索引多范围查找(Multi-Range Read)` 优化器将随机 io 转化为顺序 io，以降低查询过程中 io 开销的一种手段
- `BKA(Batched Key Access)`，，在表连接过程中为了提升 join 性能而使用的 join buffer，其作用是在读取被 join 表的记录时，使用顺序 io(BKA 被使用的标识是执行计划的 extra 信息中会有 BKA 信息)。BKA优化技术在join中使用，特别是在执行连接操作时，如果一个表上的索引已经排序，而另一个表上的连接列也是有序的，那么MySQL可以使用BKA来批量访问这两个表。它允许优化器批量访问索引，减少索引访问的次数，从而提高join的性能。
- `BNL(Block Nested Loop)` BNL优化技术也是在join中使用的。当join无法使用更高级的连接算法（如索引连接或哈希连接）时，MySQL会使用BNL。BNL通过逐行读取两个表的数据，并执行循环匹配操作，以获取满足连接条件的结果。虽然BNL可能会导致性能较低，但在某些情况下，它仍然是执行join的一种有效方法。

---

```markdown
ICP的原理很简单。当 MySQL 执行查询语句时，它会根据查询条件选择合适的索引来访问数据。在传统的执行方式中，MySQL 首先通过索引找到满足条件的记录的主键，然后再根据主键值从数据表中获取记录。而索引条件下推则在索引访问阶段就进行条件过滤，只返回满足查询条件的记录的主键，避免了不必要的主键查找操作。

这样做的好处是减少了磁盘 IO 和网络传输，提高了查询效率。特别是对于那些返回记录较多但满足查询条件的记录较少的查询，索引条件下推可以大幅提升性能。
```

这些概念太抽象了，简单来说就是“ICP就是把本应executor执行的，推给SE来执行”

仍然用图书馆类比的话，ICP相当于在图书检索系统操作员（executor）正式检索之前，由图书馆工作人员（存储引擎）利用索引目录（索引）进行的预筛选，这样可以减少操作员需要检查的书籍数量，提高整体检索效率。

BKA和BNL都是在join操作时才会使用的优化技术

```markdown
- ICP（Index Condition Pushdown）：ICP在优化器中是一项重要的优化技术，它类似于图书馆的索引目录。在图书馆中，索引目录帮助读者快速找到所需书籍的位置。类比到MySQL中，ICP会尽可能将查询条件下推至存储引擎层级，以减少不必要的数据读取，提高查询效率。
- MRR（Multi-Range Read）：MRR是一种批量读取技术，类似于在图书馆中一次性获取多本书。MRR允许MySQL在存储引擎层级批量读取满足查询条件的多个数据块，以减少磁盘I/O操作，提高查询性能。
- BKA（Batch Key Access）：BKA是一种批量键访问技术，类似于在图书馆中通过预定书架号快速获取多本书。在MySQL中，BKA允许优化器批量访问索引，以减少索引访问的次数，提高查询速度。
- BNL（Block Nested Loop）：BNL是一种块嵌套循环技术，类似于在图书馆中通过遍历多个书架来查找所需书籍。在MySQL中，BNL用于处理连接操作，它会逐行读取两个表的数据，并执行循环匹配操作，以获取符合连接条件的结果。
- Index Dive：Index Dive类似于在图书馆中通过索引快速定位到需要的书籍的过程。在MySQL中，Index Dive是一种优化技术，它允许优化器通过索引的跳跃访问，直接定位到满足查询条件的数据，而无需完全扫描索引。
```

ICP就是“把查询条件放到存储引擎，能提高查询效率”，通俗来说就是，在查询过程中，直接在查询引擎层的 API 获取数据时，实现“非直接索引”过滤条件的筛选，而不是查询引擎层查询出来之后在 server 层筛选。

再则，ICP更适合那种大量数据，但是其中只有极少数满足查询条件的场景。

```markdown
MRR是一种针对读取操作的优化技术。它通过在一个请求中读取多个连续范围的数据，以减少读取磁盘的次数。MRR通常用于处理顺序扫描（Sequential Scan）或范围查询（Range Query）等需要从磁盘读取大量连续数据的场景。通过减少磁盘IO次数，MRR可以显著提高读取操作的性能。
```

MRR主要关注的是优化读取操作的效率

这些优化器技术都旨在提高查询性能，减少不必要的磁盘I/O和数据扫描







```markdown
- 开启`慢查询日志`来定位慢 sql（设置需要优化的 SQL 语句的执行时间，记录下超过该设置时间的语句，即为需要优化的语句）
- 用`show status`了解各种 SQL 的执行效率，定位执行效率低的 SQL 语句
- 用`explain`分析效率低的 SQL 语句
- 用`show profile`找到 SQL 耗时瓶颈
  - 使用 profiling 机制，记录下来每条 SQL 语句的执行时间，找出执行比较慢的语句，即为需要优化的语句
  - 查看 MySQL 如何使用索引来处理 select 语句以及连接表，更好地使用索引，写出更好的查询语句
- 用`trace`分析优化器选择执行计划。查询 SQL 语句会执行多长时间，CPU 使用量，执行过程中 systemlock，table lock 花了多长时间。

---

***分析执行计划、矫正行数、添加索引、避免回表、使用 ICP、优化字符串索引、控制 flush 时机、加快 innoDB 刷盘、避免对索引字段做函数操作。***

- 预发跑 sql explain
- 看一下行数对不对，不对可以用`analyze table t`矫正
- 添加索引，索引不一定是最优的，`force index`强制走索引，但是不建议使用
- 查看是否存在回表的情况
- 覆盖索引避免回表，不用*
- 合理安排联合索引的顺序
- MySQL5.6 之后使用 ICP 减少回表次数
- 给字符串加索引，用`前缀索引`、`倒序存储`、`hash`
- 数据库的 flush 时机
- innoDB 刷盘速度，脏页比例、redolog 写盘速度
- 索引字段不要做函数操作，会破坏索引值的有序性，优化器会放弃走树结构。如果触发隐式转换，也会走 cast 函数，会放弃走索引

```


## 《MySQL实战45讲》





```yaml
  qs:
    - q: "***heap table(堆表), IOT(索引组织表Index Organization Table), HOT(Heap Organized Table)***"
      x: |
        pg中的表是堆表。mysql Innodb引擎中的表是IOT。oracle中既支持堆表，也支持IOT。

        从这个角度来看，pgsql的heap就是mysql的memory，而IOT就是mysql的InnoDB。

        mysql的MyISam既不是heap也不是IOT，而是HOT
    - q: "***存储引擎***"
      u: https://www.51cto.com/article/705136.html


    - q: 为什么会产生分布式DB？
      u: https://lvwenhan.com/tech-epic/507.html


    - q: DB的演化

    - q: DB 故障恢复机制的演化
      u: https://catkang.github.io/2019/01/16/crash-recovery.html

    - q: OLTP (Online Transaction Processing，联机事务处理), OLAP (Online Analytical Processing，联机分析处理), HTAP (Hybrid Transactional and Analytical Processing) 成为主流数据库的一项基础能力
      x: |
        分别针对不同的应用场景和需求

        - OLTP 侧重于事务处理，强调快速响应和数据的一致性。
        - OLAP 侧重于数据分析，强调数据的读取速度和多维分析能力。
        - HTAP 尝试结合OLTP和OLAP的特点，支持在一个系统中同时进行事务处理和数据分析。

        从应用场景、数据模型、查询类型、性能要求、数据量、数据更新频率、系统架构都不同
    - q: 湖仓一体是啥? 数据仓库、数据湖
      x: 数据仓库里的是结构化数据，但是全部数据（structured, semi-structured, non-structured）都可以忘数据湖里扔

    - q: "***B+Tree SE***"
      u: https://www.youtube.com/watch?v=9XtACKzFIRc
      x: 这个视频相当有干货，从存储引擎为什么使用bptree说起，到各种tree的比较，再到写操作时bptree会执行哪些操作，再到这几种使用bptree的存储引擎分别是怎么保证ACID的，再到innodb和boltdb使用bptree的具体细节。

```





Innodb的PAGE结构与HEAP结构的类似，不过在空闲空间管理上是完全不同的。前面是FILE HEADER/PAGE HEADER，中间是数据记录，数据记录也是从低地址往高地址写，和Oracle相反。这是因为BTREE存储结构不需要和slotted page一样，在块里放一个指示器，其行指示器的功能被BTREE替代了。

Innodb的这种存储结构，并不存在一个十分友好的类似Oracle的记录物理地址的ROWID这样的结构。所以要想定位某条数据记录，需要使用主键或者簇主键的方式来实现。主键可以定义某条记录的唯一性地址，因此Mysql的某张表上的其他索引(secondary index)的索引中存储的键值不像Oracle那样存储ROWID就可以了，而是存储的是主键中这一行的地址指针。基于一个secondary index的查询首先找出某些行的主键，然后再去扫描一次主键索引，才能找到相关行的地址，再找到这条记录。比起有rowid的Oracle数据库，这里多了一次主键索引的扫描。

可能有些朋友会觉得，是不是heap结构一定优于BTREE结构呢?其实还是回到今天的标题，没有完美的存储引擎。针对不同的应用场景，heap和BTREE各有优势。BTREE结构写入数据时按主键排序的，而且并发写入时数据并不是按照插入顺序写入数据块，如果主键存在一定的无序性，那么并发写入的数据可以被打散到多个块中，从而缓解热块冲突的压力。而二级索引的结构虽然对读取数据的操作有影响，对于存在多条索引的数据写入，数据修改，是有优势的。因为只要主键的键值不变，行数据的变化，行在数据块中存储的变化，不需要变更第二索引。

因此我们可以十分明确的肯定，不同的存储结构都各有利弊，并不能很直接的说哪种更好。不过在开发高并发，大数据量的系统的时候，了解存储引擎的一些特点，可以有效的避免一些问题。比如在Mysql、达梦等数据库中建表，尽可能定义一个显式的主键，从而避免系统自动添加主键。另外如果某张表的热块冲突特别严重的时候，主键可以考虑选择随机性的数据，而不是单边增长的数据，就可以有效的进行数据打散，从而降低热块冲突的可能性。

没看懂想表达什么

mysql的memory引擎就是pgsql的heap引擎

所以“那为什么mysql innodb使用bptree，而不是memory引擎呢？有啥区别？”

```markdown
Heap表，即使用MEMORY存储引擎的表，这种表的数据存储在内存中，由于硬件问题或者断电，数据容易丢失，所以只能从其他数据表中读取数据作为临时表或者只读缓存来使用。
```

storage, transaction, persist 几个方面


---


```markdown
再看数据存储领域，有两个“极端”发展方向：

1、加快读：通过素引 1（日 + 树、二份查找树等方式），提高查询速度，但是写入数据时要维护索引，因此会降低写入效率。
2、加快写：纯日志型，数据以 append 追加的方式顺序写入，不加索引，使得写入速度非常高 (理论上可接近 内存随机写 速度），但是缺乏索引支持，因此查询性能低。

基于这两个极端，又衍生出来了了类最具代表性的底层索引结构：

1、哈希索引：通过哈希西数将 key 映射成数据的存储地址，适用于等值查询等简单场景，对于比较查询、范围查询等复杂场景无能为力。
2、B/B+ Tree 索引：最常见的索引类型，重点考虑的是读性能，它是很多传统关系型数据库，比如 MysQL、Oracle 的底层结构。
3、LSM Tree 索引：数据以 Append 方式追加写入日志文件，优化了写但是又没显著降低读性能，众多 NosQL 存储系统比如 Big Table, HBase, Cassandra, RocksDB 的底层结构。

```





---



```yaml
  qs:
    - q: 啥是NewSQL? 怎么评价?
      u: https://pigsty.cc/zh/blog/db/distributive-bullshit/

```



NewSQL 最大的特点就是 ***使用非 B 树磁盘存储结构（一般为 LSM-Tree），在上面构筑一个兼容 SQL 常用语句和事务的兼容层，这样既可以享受大规模 LSM-Tree 集群带来的扩展性和高性能，也可以尽量少改动现有应用代码和开发习惯***，把悲伤留给自己了属于是。目前比较常见的 NewSQL 有 ClustrixDB、NuoDB、VoltDB，国内的 TiDB 和 OceanBase 也属于 NewSQL，但他们俩有本质区别，我们下面会详细讨论。

```markdown
NewSQL的重要特征是：主打“分布式”的概念，通过“分布式”解决水平扩展性与容灾高可用两个问题，但会因为分布式的内在局限性而牺牲很多功能（例如各种复杂JOIN），只能支持简单有限的查询种类。在高可用/容灾方面，分布式数据库与主从复制并没有质的区别，因此其主要特征可以概括为“以质换量”。

然而，对很多企业而言，牺牲功能换取伸缩性很可能是一个伪需求或弱需求。OLTP数据库是一种工作记忆，极少有业务能超出单机主从的极限（参考值：单集群写入上限十几万TPS，读取几十万～百万QPS，数据量几TB～百TB），更何况还有分库分表的传统优化方式。在我所接触到的大量用户中，超出单机PG处理能力的业务场景屈指可数。一个中型互联网公司或银行的全部TP数据约在百TB量级。而绝大多数企业的全部数据，终其生命周期也超不过这个瓶颈。至于性能就更不重要了：过早优化是万恶之源，很多企业的DB性能余量足够让他们把所有业务逻辑用存储过程编写，然后快乐地跑在数据库里面。
```

NewSQL主打拓展性，但是本身支持的feat远不如传统OLTP数据库。






