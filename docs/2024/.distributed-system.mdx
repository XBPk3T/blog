



```yaml
  qs:
    - q: “三高架构”
      x: |
        高并发：

        - *扩容*
        - 无状态
        - 拆分
        - 服务化
        - 消息队列
        - 数据异构
        - 缓存银弹
        - 并发化（异步并发）
        - 连接池
        - 线程池
        - 分布式任务

        高可用：

        - 系统高可用的核心是`备份 + 自动切换`
        - 如果压力（不只是数据库或者服务器，各个层的压力）太大，考虑做“集群”，所以，也可以认为是`集群 + 自动切换`，核心思想是“去单点”，只不过是机器多少的问题

        ---

        - 事前：副本；隔离；配额，提前预案，探知
        - 事发：监控和报警
        - 事中：降级，回滚，应急预案，fairXXX 系列
        - 事后：复盘，思考，技改

        ---

        - `熔断`，通过隔离实现故障隔离
        - `降级`，通过降级实现部分可用，有损服务
        - `回滚`，通过回滚机制快速修复错误版本
        - `限流`，通过“限流”保护服务受到雪崩的影响
        - `切流量`
        - `兜底容灾`


    - q: 怎么理解DDD
      x: 一般 ddd 会划分几个领域，核心域 (核心业务），通用域 (比如用户中心），支撑域 (比如 MySQL REDIS KAFKA)，ddd 最难的应该就是核心域的服务拆分，但是不管怎么拆分每个服务一般都有自己的缓存 (Redis），持久化 (mySQL)，事件（katka)，服务与服务之间一般通过事件做通信

```




```yaml
    - q: "***分布式场景常见问题：分布式场景下的`分布式事务`，`幂等控制`，`异步消息乱序`，和`补偿方案`等问题？***"
      x: |
        目前的主流方案是 *`待处理内容写入本地表`+`事务外实时触发`+`定时调度补偿`* ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理

        - 分布式事务
          - 事务中直接 RPC 调用达到强一致性
          - 事务中进行异步消息推送
          - 解决方案
          - 目前我们使用的解决方案
        - 幂等控制
        - 异步消息乱序
          - 异步消息结合状态驱动
        - 补偿方案
          - `HTTP同步调用的补偿`
          - `异步消息消费失败的补偿`

    - q: 如何解决时间漂移问题在多处理器系统、分布式系统中带来的时序相关的问题？在分布式系统中，怎么使用逻辑时钟和向量时钟？这两种方案做个比较。哪种方法更好呢？
      u: https://www.hitzhangjie.pro/blog/2021-03-09-%E8%81%8A%E8%81%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4/
      x: 分布式数据库、分布式锁等场景使用向量时钟。向量时钟相比逻辑时钟更加复杂。

    - q: most common problems in distributed scenarios? How to resolve?
      x: distributed transactions, idempotent control, async msg out-of-order, compensation schemes
    - q: "***分布式场景下的分布式事务，幂等控制，异步消息乱序，和补偿方案等问题？***"
      x: 目前的主流方案是 *`待处理内容写入本地表`+`事务外实时触发`+`定时调度补偿`* ，可以基本满足`分布式事务`，`同步异步补偿`，`实时非实时触发`等复杂场景的处理


    - q: 服务治理（包括但不限于：限流，熔断、负载、监控、鉴权、服务发现和注册等等）
    - q: 服务容错（失败切换（failover），失败通知（failback），失败缓存（failcache）， 快速失败（failfast）、双发 backuprequest）
      x: |
        服务容错的常用手段：

        #FailOver 失败自动切换
        服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试次数。要求服务调用幂等，不管调用多少次，只要是同一个调用，返回结果必须相等，适合读请求。

        #FailBack 失败通知
        消费者调用失败后，不再重试。而是根据失败的详细信息，决定后续的执行策略。对于非幂等的调用场景，不能重试，而是应该查询服务端状态，看调用到底是否实际生效。

        #FailCache 失败缓存
        服务消费者调用失败或者超时后，不立即重试，而是间隔一段时间再次尝试发起调用。

        #FailFast 快速失败
        消费者调用一次失败后，不再重试。一般非核心业务调用，采用快速失败，记录日志后就返回。

        一般幂等的使用FailOver或者FailCache，不是幂等调用选择FailBack或者FailFast。

```





为什么很多分布式系统都是以DAG（Directed acyclic graph ）实现运算的？



